<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Context.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">fr.kbertet.context</a> &gt; <span class="el_source">Context.java</span></div><h1>Context.java</h1><pre class="source lang-java linenums">package fr.kbertet.context;

/*
 * Context.java
 *
 * Copyright: 2010-2014 Karell Bertet, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 */

import java.io.IOException;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;

import fr.kbertet.util.ComparableSet;
import fr.kbertet.util.Couple;
import fr.kbertet.dgraph.Node;
import fr.kbertet.lattice.ClosureSystem;
import fr.kbertet.lattice.ArrowRelation;
import fr.kbertet.lattice.ConceptLattice;
import fr.kbertet.lattice.Concept;
import fr.kbertet.lattice.Lattice;
import fr.kbertet.context.io.Factory;
import fr.kbertet.io.Serializer;

/**
 * This class gives a standard representation for a context.
 * A context is a binary table, with attributes in column, and observations
 * in row.
 *
 * A context is composed of
 *
 * - attributes, a treeset of comparable objects;
 * - observations, a treeset of comparable objects;
 * - a Galois connexion (extent,intent) between objects and attributes where
 * `extent` is a TreeMap that associates to each attribute a TreeSet of observations and
 * `intent` is a TreeMap that associates  to each observation a TreeSet of attributes.
 *
 * This class provides methods implementing classical operation on a context:
 * closure, reduction, reverse, ...
 *
 * A context owns properties of a closure system, and thus extends the abstract class
 * {@link ClosureSystem} and implements methods {@link #getSet} and {@link #closure}.
 * Therefore, the closed set lattice of a context can be generated by invoking method {@link ClosureSystem#closedSetLattice} of a closure system.
 * However, this class also provides a method generating the concept lattice of this component
 * by completing each closed set of the closed set lattice.
 *
 * A context can be instancied from and save to a text file in the following format:
 *
 * - the list of observations separated by a space on the first line;
 * - the list of attrbutes separated by a space on the second line;
 * - then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
 *
 * ~~~
 * Observations: 1 2 3
 * Attributes: a b c d e
 * 1: a c
 * 2: a b
 * 3: b d e
 * 4: c e
 * ~~~
 *
 * ![Context](Context.png)
 *
 * @uml Context.png
 * !include resources/fr/kbertet/context/Context.iuml
 * !include resources/fr/kbertet/lattice/ClosureSystem.iuml
 *
 * hide members
 * show Context members
 * class Context #LightCyan
 * title Context UML graph
 */
public class Context extends ClosureSystem {
    /* ------------- FIELD ------------------ */

    /**
     * A set of observations.
     */
    private TreeSet&lt;Comparable&gt; observations;

    /**
     * A set of attributes.
     */
    private TreeSet&lt;Comparable&gt; attributes;

    /**
     * A map to associate a set of attributes to each observation.
     */
    private TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; intent;

    /**
     * A map to associate a set of observations to each attribute.
     */
    private TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; extent;

    /* ------------- BITSET ADDON ------------------ */

    /**
     * A bit set for intent.
     */
    private TreeMap&lt;Comparable, BitSet&gt; bitsetIntent;

    /**
     * A bit set for extent.
     */
    private TreeMap&lt;Comparable, BitSet&gt; bitsetExtent;

    /**
     * An array for observations.
     */
    private ArrayList&lt;Comparable&gt; arrayObservations;

    /**
     * An array for attributes.
     */
    private ArrayList&lt;Comparable&gt; arrayAttributes;

    /* ------------- CONSTRUCTORS ------------------ */

    /**
     * Constructs a new empty context.
     */
<span class="fc" id="L134">    public Context() {</span>
<span class="fc" id="L135">        this.init();</span>
<span class="fc" id="L136">    }</span>

    /**
     * Constructs a new context as a copy of the specified context.
     *
     * @param   context  context to be copied
     */
    public Context(Context context) {
<span class="fc" id="L144">        this();</span>
<span class="fc" id="L145">        this.attributes.addAll(context.getAttributes());</span>
<span class="fc" id="L146">        this.observations.addAll(context.getObservations());</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (Comparable o : context.getObservations()) {</span>
<span class="fc" id="L148">            this.intent.put(o, new TreeSet(context.getIntent(o)));</span>
<span class="fc" id="L149">        }</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (Comparable a : context.getAttributes()) {</span>
<span class="fc" id="L151">            this.extent.put(a, new TreeSet(context.getExtent(a)));</span>
<span class="fc" id="L152">        }</span>
<span class="fc" id="L153">        this.setBitSets();</span>
<span class="fc" id="L154">    }</span>

    /**
     * Constructs this component from the specified file.
     *
     * The file have to respect a certain format:
     *
     * The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     *
     * ~~~
     * Observations: 1 2 3
     * Attributes: a b c d e
     * 1: a c
     * 2: a b
     * 3: b d e
     * 4: c e
     * ~~~
     *
     * Each observation must be declared on the first line, otherwise, it is not added
     * Each attribute must be declared on the second line, otherwise, it is not added
     *
     * @param   filename  the name of the file
     *
     * @throws  IOException  When an IOException occurs
     */
<span class="fc" id="L181">    public Context(String filename) throws IOException {</span>
<span class="fc" id="L182">        this.parse(filename);</span>
<span class="fc" id="L183">    }</span>

    /**
     * Initialise the context.
     *
     * @return  this for chaining
     */
    public Context init() {
<span class="fc" id="L191">        this.observations = new TreeSet();</span>
<span class="fc" id="L192">        this.attributes = new TreeSet();</span>
<span class="fc" id="L193">        this.intent = new TreeMap();</span>
<span class="fc" id="L194">        this.extent = new TreeMap();</span>
<span class="fc" id="L195">        this.bitsetIntent = new TreeMap();</span>
<span class="fc" id="L196">        this.bitsetExtent = new TreeMap();</span>
<span class="fc" id="L197">        this.arrayObservations = new ArrayList();</span>
<span class="fc" id="L198">        this.arrayAttributes = new ArrayList();</span>
<span class="fc" id="L199">        return this;</span>
    }

    /**
     * Generates a partially random context.
     *
     * @param nbObs number of observations
     * @param nbGrp number of groups of attributes . Attributes are grouped such that each observation has one attribute per group.
     * @param nbAttrPerGrp number of attributes per group.
     * @return randomly generated context
     */
    public static Context random(int nbObs, int nbGrp, int nbAttrPerGrp) {
<span class="fc" id="L211">        Context ctx = new Context();</span>
        // Generates Observations.
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (int i = 1; i &lt;= nbObs; i++) {</span>
<span class="fc" id="L214">            ctx.addToObservations(Integer.toString(i));</span>
        }
        // Generates Attributes.
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (int i = 1; i &lt;= nbGrp; i++) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            for (int j = 1; j &lt;= nbAttrPerGrp; j++) {</span>
<span class="fc" id="L219">                int q = i;</span>
<span class="fc" id="L220">                int rem = 0;</span>
<span class="fc" id="L221">                String name = &quot;&quot;;</span>
                do {
<span class="fc" id="L223">                    rem = q % 26;</span>
<span class="fc" id="L224">                    q = q / 26;</span>
<span class="fc" id="L225">                    name = name + (char) (rem + 65);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                } while (q != 0);</span>
<span class="fc" id="L227">                ctx.addToAttributes(name + Integer.toString(j)); // These names are cool ...</span>
            }
        }
        // Generates all requested observations.
<span class="fc" id="L231">        Random r = new Random();</span>
<span class="fc" id="L232">        int attr = r.nextInt(nbAttrPerGrp) + 1;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (int i = 1; i &lt;= nbObs; i++) { // i : Observation</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            for (int j = 1; j &lt;= nbGrp; j++) { // j : Familly</span>
<span class="fc" id="L235">                int q = j;</span>
<span class="fc" id="L236">                int rem = 0;</span>
<span class="fc" id="L237">                String name = &quot;&quot;;</span>
                do {
<span class="fc" id="L239">                    rem = q % 26;</span>
<span class="fc" id="L240">                    q = q / 26;</span>
<span class="fc" id="L241">                    name = name + (char) (rem + 65);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                } while (q != 0);</span>
<span class="fc" id="L243">               name = name + Integer.toString(attr); // These names are really cool, aren't they ?</span>
<span class="fc" id="L244">               ctx.addExtentIntent(Integer.toString(i), name);</span>
<span class="fc" id="L245">               attr = r.nextInt(nbAttrPerGrp) + 1;</span>
            }
        }
<span class="fc" id="L248">        ctx.setBitSets();</span>
<span class="fc" id="L249">        return ctx;</span>
    }

    /**
     * Returns subcontext with selected obs and attr.
     *
     * @param obs : observations to be keeped
     * @param attr : attributes to be keeped
     * @return subcontext with selected obs and attr.
     */
    public Context getSubContext(TreeSet&lt;Comparable&gt; obs, TreeSet&lt;Comparable&gt; attr) {
<span class="fc" id="L260">        Context ctx = new Context();</span>
<span class="fc" id="L261">        ctx.addAllToAttributes(attr);</span>
<span class="fc" id="L262">        ctx.addAllToObservations(obs);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (Comparable o : obs) {</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            for (Comparable a : attr) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                if (this.getIntent(o).contains(a)) {</span>
<span class="fc" id="L266">                    ctx.addExtentIntent(o, a);</span>
                }
<span class="fc" id="L268">            }</span>
<span class="fc" id="L269">        }</span>
<span class="fc" id="L270">        ctx.setBitSets();</span>
<span class="fc" id="L271">        return ctx;</span>
    }
    /**
     * Returns the context defining the concept lattice of arrow-closed subcontexts of this component.
     *
     * Each observation of the returned context is a $1$-generated arrow-closed subcontext.
     * The observation used to generate the context is used as a name for the subcontext.
     * Attributes are the same of this component, and are used to defined the subcontext.
     *
     * @return the context defining the concept lattice of arrow-closed subcontexts of this component.
     */
    public Context getArrowClosedSubContext() {
<span class="fc" id="L283">        Context result = new Context();</span>
<span class="fc" id="L284">        result.addAllToAttributes(this.getAttributes());</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        for (Comparable o : this.getObservations()) {</span>
<span class="fc" id="L286">            result.addToObservations(o);</span>
<span class="fc" id="L287">            TreeSet&lt;Comparable&gt; setO = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L288">            setO.add(o);</span>
<span class="fc" id="L289">            Context c = this.arrowClosureObject(setO);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            for (Comparable a : c.getAttributes()) {</span>
<span class="fc" id="L291">                result.addExtentIntent(o, a);</span>
<span class="fc" id="L292">            }</span>
<span class="fc" id="L293">        }</span>
<span class="fc" id="L294">        return result;</span>
    }
    /**
     * Returns a list of subcontexts such that the concept lattice of this component is obtained from a subcontext by doubling a convex.
     *
     * Each subcontext defines a concept lattice L. With the getDivisionConvex method, a convex C of this concept lattice is obtained.
     * By doubling the convex set C of L, we get L[C], the concept lattice of this component.
     *
     * @return a list of subcontexts such that the concept lattice of this component is obtained from a subcontext by doubling a convex.
     */
    public ArrayList&lt;Context&gt; getDivisionContext() {
<span class="fc" id="L305">        Context arrowCtx = this.getArrowClosedSubContext();</span>
<span class="fc" id="L306">        arrowCtx.reverse(); // We need co-atoms which are atoms of the reverse context.</span>
<span class="fc" id="L307">        ConceptLattice clArrowClosed = arrowCtx.conceptLattice(true); // This lattice is fun :-)</span>
<span class="fc" id="L308">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; coAtoms = clArrowClosed.immediateSuccessors(clArrowClosed.bottom(), arrowCtx);</span>
        // Check if the complement of coAtoms is &quot;empty&quot;.
        // Only these coAtoms are kept
<span class="fc" id="L311">        ArrayList&lt;Context&gt; goodCoAtoms = new ArrayList&lt;Context&gt;();</span>
        // Be careful that the concept has been reversed
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (int i = 0; i &lt; coAtoms.size(); i++) {</span>
<span class="fc" id="L314">            TreeSet&lt;Comparable&gt; attrComp = (TreeSet&lt;Comparable&gt;) this.getAttributes().clone(); // Initial context</span>
<span class="fc" id="L315">            TreeSet&lt;Comparable&gt; attr = arrowCtx.getExtent(coAtoms.get(i));</span>
<span class="fc" id="L316">            attrComp.removeAll(attr); // As arrowCtx is reversed, Extent means Intent.</span>
<span class="fc" id="L317">            TreeSet&lt;Comparable&gt; obsComp = (TreeSet&lt;Comparable&gt;) this.getObservations().clone(); // Initial context</span>
<span class="fc" id="L318">            TreeSet&lt;Comparable&gt; obs = this.arrowClosureObject(coAtoms.get(i)).getObservations();</span>
<span class="fc" id="L319">            obsComp.removeAll(obs);</span>
<span class="fc" id="L320">            boolean cross = false; // If there is a cross, it is not empty.</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            for (Comparable o : obsComp) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                for (Comparable a : attrComp) {</span>
<span class="pc bpc" id="L323" title="2 of 4 branches missed.">                    cross = cross || this.getIntent(o).contains(a);</span>
<span class="fc" id="L324">                }</span>
<span class="fc" id="L325">            }</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">            if (!cross) {</span>
<span class="fc" id="L327">                Context subContext = this.getSubContext(obs, attr);</span>
<span class="fc" id="L328">                goodCoAtoms.add(subContext);</span>
            }
        }
<span class="fc" id="L331">        return goodCoAtoms;</span>
    }
    /**
     * Returns a convex set of the concept lattice of c which can be doubled to recover the concept lattice of this component.
     *
     * This method must be used with contexts returned by the getDivisionContext.
     * In other cases, it is meaningless.
     *
     * @param ctx context from which the convex set is computed.
     *
     * @return a convex set of the concept lattice of c which can be doubled to recover the concept lattice of this component.
     */
    public TreeSet&lt;Node&gt; getDivisionConvex(Context ctx) {
<span class="fc" id="L344">        ConceptLattice factor = ctx.conceptLattice(true);</span>
<span class="fc" id="L345">        TreeSet&lt;Node&gt; convex = new TreeSet&lt;Node&gt;();</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        for (Node n : factor.getNodes()) {</span>
<span class="fc" id="L347">            Concept c = (Concept) n;</span>
<span class="pc bpc" id="L348" title="2 of 4 branches missed.">            if (!c.getSetB().containsAll(this.getExtent(c.getSetA()))</span>
                    &amp;&amp; !c.getSetA().containsAll(this.getIntent(c.getSetB()))) {
<span class="fc" id="L350">                convex.add(n);</span>
            }
<span class="fc" id="L352">        }</span>
<span class="fc" id="L353">        return convex;</span>
    }
    /* --------------- HANDLING METHODS FOR ATTRIBUTES AND OBSERVATIONS ------------ */

   /**
    * Returns the set of attributes of this component.
    *
    * @return  the set of attributes of this component
    */
    public TreeSet&lt;Comparable&gt; getAttributes() {
<span class="fc" id="L363">        return this.attributes;</span>
    }

    /**
     * Checks if the specified attribute belong to this component.
     *
     * @param   att  an attribute
     *
     * @return  true if the attribute belongs to this component
     */
    public boolean containsAttribute(Comparable att) {
<span class="fc" id="L374">        return this.attributes.contains(att);</span>
    }

    /**
     * Checks if the specified set of attributes belongs to this component.
     *
     * @param   set  set of attributes
     *
     * @return  true if all attributes belong to this component
     */
    public boolean containsAllAttributes(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L385">        return this.attributes.containsAll(set);</span>
    }

    /**
     * Adds the specified element to the set of attributes of this component.
     *
     * @param   att  an attribute
     *
     * @return  true if the attribute was successfully added
     */
    public boolean addToAttributes(Comparable att) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (!this.containsAttribute(att)) {</span>
<span class="fc" id="L397">            this.extent.put(att, new TreeSet&lt;Comparable&gt;());</span>
        }
<span class="fc" id="L399">        boolean ok = this.attributes.add(att);</span>
<span class="fc" id="L400">        this.setBitSets();</span>
<span class="fc" id="L401">        return ok;</span>
    }

    /**
     * Adds the set of specified element to the set of attributes of this component.
     *
     * @param   set  set of attributes
     *
     * @return  true if all attributes were successfully added
     */
    public boolean addAllToAttributes(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L412">        boolean all = true;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">        for (Comparable att : set) {</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (!this.addToAttributes(att)) {</span>
<span class="fc" id="L415">                all = false;</span>
            }
<span class="fc" id="L417">        }</span>
<span class="fc" id="L418">        this.setBitSets();</span>
<span class="fc" id="L419">        return all;</span>
    }

    /**
     * Removes the specified element from the set of attributes of this component
     * and from all the intents it belongs to.
     *
     * @param   att  an attribute
     *
     * @return  true if the attribute was successfully removed
     */
    public boolean removeFromAttributes(Comparable att) {
<span class="fc" id="L431">        this.extent.remove(att);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (Comparable o : this.getObservations()) {</span>
<span class="fc" id="L433">            this.intent.get(o).remove(att);</span>
<span class="fc" id="L434">        }</span>
<span class="fc" id="L435">        boolean ok = this.attributes.remove(att);</span>
<span class="fc" id="L436">        this.setBitSets();</span>
<span class="fc" id="L437">        return ok;</span>
    }

   /**
    * Returns the set of observations of this component.
    *
    * @return  the set of observations
    */
    public TreeSet&lt;Comparable&gt; getObservations() {
<span class="fc" id="L446">        return this.observations;</span>
    }

    /**
     * Checks if the specified observation belongs to this component.
     *
     * @param   obs  an observation
     *
     * @return  true if the observation belongs to this component
     */
    public boolean containsObservation(Comparable obs) {
<span class="fc" id="L457">        return this.observations.contains(obs);</span>
    }

    /**
     * Checks if the specified set of observations belong to this component.
     *
     * @param   set  set of observations
     *
     * @return  true if all the observations are in this component
     */
    public boolean containsAllObservations(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L468">        return this.observations.containsAll(set);</span>
    }

    /**
     * Adds the specified element to the set of observations of this component.
     *
     * @param   obs  an observation
     *
     * @return  true if the observation was successfully added
     */
    public boolean addToObservations(Comparable obs) {
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (!this.containsObservation(obs)) {</span>
<span class="fc" id="L480">            this.intent.put(obs, new TreeSet&lt;Comparable&gt;());</span>
        }
<span class="fc" id="L482">        boolean ok = this.observations.add(obs);</span>
<span class="fc" id="L483">        this.setBitSets();</span>
<span class="fc" id="L484">        return ok;</span>
    }

    /**
     * Adds the set of specified element to the set of observations of this component.
     *
     * @param   set  set of observations
     *
     * @return  true if all observations were successfully added
     */
    public boolean addAllToObservations(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L495">        boolean all = true;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        for (Comparable obs : set) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (!this.addToObservations(obs)) {</span>
<span class="fc" id="L498">                all = false;</span>
            }
<span class="fc" id="L500">        }</span>
<span class="fc" id="L501">        this.setBitSets();</span>
<span class="fc" id="L502">        return all;</span>
    }

    /**
     * Removes the specified element from the set of observations of this component.
     * and from all the extents it belongs to
     *
     * @param   obs  an observation
     *
     * @return  true if the observation was removed
     */
    public boolean removeFromObservations(Comparable obs) {
<span class="fc" id="L514">        this.intent.remove(obs);</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">        for (Comparable att : this.getAttributes()) {</span>
<span class="fc" id="L516">            this.extent.get(att).remove(obs);</span>
<span class="fc" id="L517">        }</span>
<span class="fc" id="L518">        boolean ok = this.observations.remove(obs);</span>
<span class="fc" id="L519">        this.setBitSets();</span>
<span class="fc" id="L520">        return ok;</span>
    }

    /**
     * Set the needed structures for the bitset optimization.
     * WARNING: this must be called each time your dataset change
     */
    public void setBitSets() {
<span class="fc" id="L528">        this.setMaps();</span>
<span class="fc" id="L529">        this.setBitSetsIntentExtent();</span>
<span class="fc" id="L530">    }</span>

    /**
     * Set the mapping structure for the bitset optimization.
     */
    private void setMaps() {
<span class="fc" id="L536">        this.arrayAttributes = new ArrayList();</span>
<span class="fc" id="L537">        this.arrayObservations = new ArrayList();</span>
<span class="fc" id="L538">        Iterator&lt;Comparable&gt; i = this.attributes.iterator();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        while (i.hasNext()) {</span>
<span class="fc" id="L540">            this.arrayAttributes.add(i.next());</span>
        }
<span class="fc" id="L542">        i = this.observations.iterator();</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        while (i.hasNext()) {</span>
<span class="fc" id="L544">            this.arrayObservations.add(i.next());</span>
        }
<span class="fc" id="L546">    }</span>

    /**
     * Set the extent and intent structures for the bitset optimization.
     */
    private void setBitSetsIntentExtent() {
<span class="fc" id="L552">        this.bitsetIntent = new TreeMap();</span>
<span class="fc" id="L553">        this.bitsetExtent = new TreeMap();</span>
<span class="fc" id="L554">        Iterator&lt;Comparable&gt; i = this.attributes.iterator();</span>
<span class="fc" id="L555">        BitSet b = new BitSet(this.observations.size());</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        while (i.hasNext()) {</span>
<span class="fc" id="L557">            Comparable att = i.next();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            for (Comparable c : this.extent.get(att)) {</span>
<span class="fc" id="L559">                b.set(this.arrayObservations.indexOf(c));</span>
<span class="fc" id="L560">            }</span>
<span class="fc" id="L561">            this.bitsetExtent.put(att, (BitSet) b.clone());</span>
<span class="fc" id="L562">            b.clear();</span>
<span class="fc" id="L563">        }</span>
<span class="fc" id="L564">        i = this.observations.iterator();</span>
<span class="fc" id="L565">        b = new BitSet(this.attributes.size());</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">        while (i.hasNext()) {</span>
<span class="fc" id="L567">            Comparable obs = i.next();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">            for (Comparable c : this.intent.get(obs)) {</span>
<span class="fc" id="L569">                b.set(this.arrayAttributes.indexOf(c));</span>
<span class="fc" id="L570">            }</span>
<span class="fc" id="L571">            this.bitsetIntent.put(obs, (BitSet) b.clone());</span>
<span class="fc" id="L572">            b.clear();</span>
<span class="fc" id="L573">        }</span>
<span class="fc" id="L574">    }</span>

    /* --------------- HANDLING METHODS FOR INTENT AND EXTENT ------------ */

    /**
     * Returns the set of attributes that are intent of the specified observation.
     *
     * @param   obs  an observation
     *
     * @return  the set of attributes
     */
    public TreeSet&lt;Comparable&gt; getIntent(Comparable obs) {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (this.containsObservation(obs)) {</span>
<span class="fc" id="L587">            return this.intent.get(obs);</span>
        } else {
<span class="nc" id="L589">            return new TreeSet();</span>
        }
    }

    /**
     * Returns the set of attributes that are all intent of observations of the specified set.
     *
     * @param   set  set of observations
     *
     * @return  the set of observations
     */
    public TreeSet&lt;Comparable&gt; getIntent(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L601">        TreeSet&lt;Comparable&gt; resIntent = new TreeSet(this.getAttributes());</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">        for (Comparable obs : set) {</span>
<span class="fc" id="L603">            resIntent.retainAll(this.getIntent(obs));</span>
<span class="fc" id="L604">        }</span>
<span class="fc" id="L605">        return resIntent;</span>
    }

    /**
     * Return the number of attributes that are all intent of observations of the specified set.
     *
     * @param   set  set of observations
     *
     * @return  the number of attributes
     */
    public int getIntentNb(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L616">        int size = this.getAttributes().size();</span>
<span class="fc" id="L617">        BitSet obsIntent = new BitSet(size);</span>
<span class="fc" id="L618">        obsIntent.set(0, size);</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">        for (Comparable obs : set) {</span>
            try {
<span class="fc" id="L621">                obsIntent.and(this.bitsetIntent.get(obs));</span>
<span class="nc" id="L622">            } catch (NullPointerException e) {</span>
<span class="nc" id="L623">                return 0;</span>
<span class="fc" id="L624">            }</span>
<span class="fc" id="L625">        }</span>
<span class="fc" id="L626">        return obsIntent.cardinality();</span>
    }

    /**
     * Checks if the second specified element is an intent of the first specified element.
     *
     * @param   obs  an observation
     * @param   att  an attribute
     *
     * @return  true if the attribute is an intent of the observation
     */
    public boolean containAsIntent(Comparable obs, Comparable att) {
<span class="pc bpc" id="L638" title="2 of 4 branches missed.">        if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att)) {</span>
<span class="fc" id="L639">            return this.intent.get(obs).contains(att);</span>
        } else {
<span class="nc" id="L641">            return false;</span>
        }
    }

    /**
     * Returns the set of observations that are intent of the specified attribute.
     *
     * @param   att  an attribute
     *
     * @return  the set of observations
     */
    public TreeSet&lt;Comparable&gt; getExtent(Comparable att) {
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if (this.containsAttribute(att)) {</span>
<span class="fc" id="L654">            return this.extent.get(att);</span>
        } else {
<span class="nc" id="L656">            return new TreeSet();</span>
        }
    }

    /**
     * Returns the set of observations that are all intent of attributes of the specified set.
     *
     * @param   set  set of attributes
     *
     * @return  the set of observations
     */
    public TreeSet&lt;Comparable&gt; getExtent(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L668">        TreeSet&lt;Comparable&gt; attExtent = new TreeSet(this.getObservations());</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        for (Comparable att : set) {</span>
<span class="fc" id="L670">            attExtent.retainAll(this.getExtent(att));</span>
<span class="fc" id="L671">        }</span>
<span class="fc" id="L672">        return attExtent;</span>
    }

    /**
     * Return the number of observations that are all intent of attributes of the specified set.
     *
     * @param   set  set of attributes
     *
     * @return  the number of observations
     */
    public int getExtentNb(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L683">        int size = this.getObservations().size();</span>
<span class="fc" id="L684">        BitSet attExtent = new BitSet(size);</span>
<span class="fc" id="L685">        attExtent.set(0, size);</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">        for (Comparable att : set) {</span>
            try {
<span class="fc" id="L688">                attExtent.and(this.bitsetExtent.get(att));</span>
<span class="nc" id="L689">            } catch (NullPointerException e) {</span>
<span class="nc" id="L690">                return 0;</span>
<span class="fc" id="L691">            }</span>
<span class="fc" id="L692">        }</span>
<span class="fc" id="L693">        return attExtent.cardinality();</span>
    }

    /**
     * Checks if the second specified element is an extent of the first specified element.
     *
     * @param   att  an attribute
     * @param   obs  an observation
     *
     * @return  true if the proposition is true
     */
    public boolean containAsExtent(Comparable att, Comparable obs) {
<span class="pc bpc" id="L705" title="2 of 4 branches missed.">        if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att)) {</span>
<span class="fc" id="L706">            return this.extent.get(att).contains(obs);</span>
        } else {
<span class="nc" id="L708">            return false;</span>
        }
    }

    /**
     * Adds the second specified element as intent of the first one,
     * and the first one as extent of the second one.
     * The first one has to belong to the observations set
     * and the second one to the attribute set.
     *
     * @param   obs  an observation
     * @param   att  an attribute
     *
     * @return  true if both were added
     */
    public boolean addExtentIntent(Comparable obs, Comparable att) {
<span class="pc bpc" id="L724" title="2 of 4 branches missed.">        if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att)) {</span>
<span class="pc bpc" id="L725" title="2 of 4 branches missed.">            boolean ok = this.intent.get(obs).add(att) &amp;&amp; this.extent.get(att).add(obs);</span>
<span class="fc" id="L726">            this.setBitSets();</span>
<span class="fc" id="L727">            return ok;</span>
        } else {
<span class="nc" id="L729">            return false;</span>
        }
    }

    /**
     * Removes the second specified element from the intent of the first one,
     * and the first one from the extent of the second one.
     * The first one has to belong to the observations set
     * and the second one to the attribute set.
     *
     * @param   obs  an observation
     * @param   att  an attribute
     *
     * @return  true if both were removed
     */
    public boolean removeExtentIntent(Comparable obs, Comparable att) {
<span class="nc bnc" id="L745" title="All 4 branches missed.">        if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att)) {</span>
<span class="nc bnc" id="L746" title="All 4 branches missed.">            boolean ok = this.intent.get(obs).remove(att) &amp;&amp; this.extent.get(att).remove(obs);</span>
<span class="nc" id="L747">            this.setBitSets();</span>
<span class="nc" id="L748">            return ok;</span>
        } else {
<span class="nc" id="L750">            return false;</span>
        }
    }

    /* --------------- CONTEXT HANDLING METHODS ------------ */

    /**
     * Returns a String representation of this component.
     * The following format is respected:
     *
     * The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     *
     * ~~~
     * Observations: 1 2 3
     * Attributes: a b c d e
     * 1: a c
     * 2: a b
     * 3: b d e
     * 4: c e
     * ~~~
     *
     * @return  the string representation of this component
     */
    @Override
    public String toString() {
<span class="fc" id="L777">        StringBuffer string = new StringBuffer();</span>
<span class="fc" id="L778">        string.append(&quot;Observations: &quot;);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (Comparable o : this.observations) {</span>
            // first line : All observations separated by a space
            // a StringTokenizer is used to delete spaces in the
            // string description of each observation
<span class="fc" id="L783">            StringTokenizer st = new StringTokenizer(o.toString());</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">            while (st.hasMoreTokens()) {</span>
<span class="fc" id="L785">                string.append(st.nextToken());</span>
            }
<span class="fc" id="L787">            string.append(&quot; &quot;);</span>
<span class="fc" id="L788">        }</span>

<span class="fc" id="L790">        string.append(&quot;\nAttributes: &quot;);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">        for (Comparable a : this.attributes) {</span>
            // second line : All attributes separated by a space
            // a StringTokenizer is used to delete spaces in the
            // string description of each observation
<span class="fc" id="L795">            StringTokenizer st = new StringTokenizer(a.toString());</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            while (st.hasMoreTokens()) {</span>
<span class="fc" id="L797">                string.append(st.nextToken());</span>
            }
<span class="fc" id="L799">            string.append(&quot; &quot;);</span>
<span class="fc" id="L800">        }</span>

        // next lines : All intents of observations, one on each line:
        // observation : list of attributes
        // a StringTokenizer is used to delete spaces in the
        // string description of each observation and attributes
<span class="fc" id="L806">        string.append(&quot;\n&quot;);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (Comparable o : this.observations) {</span>
<span class="fc" id="L808">            StringTokenizer st = new StringTokenizer(o.toString());</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">            while (st.hasMoreTokens()) {</span>
<span class="fc" id="L810">                string.append(st.nextToken());</span>
            }
<span class="fc" id="L812">            string.append(&quot;: &quot;);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">            for (Comparable a : this.getIntent(o)) {</span>
<span class="fc" id="L814">                st = new StringTokenizer(a.toString());</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">                while (st.hasMoreTokens()) {</span>
<span class="fc" id="L816">                    string.append(st.nextToken());</span>
                }
<span class="fc" id="L818">                string.append(&quot; &quot;);</span>
<span class="fc" id="L819">            }</span>
<span class="fc" id="L820">            string.append(&quot;\n&quot;);</span>
<span class="fc" id="L821">        }</span>
<span class="fc" id="L822">        return string.toString();</span>
    }

    /**
     * Save the description of this component in a file whose name is specified.
     *
     * @param   filename  the name of the file
     *
     * @throws  IOException  When an IOException occurs
     */
    public void save(final String filename) throws IOException {
<span class="fc" id="L833">        Serializer.getInstance().save(this, Factory.getInstance(), filename);</span>
<span class="fc" id="L834">    }</span>

    /**
     * Parse the description of this component from a file whose name is specified.
     *
     * @param   filename  the name of the file
     *
     * @return  this for chaining
     *
     * @throws  IOException  When an IOException occurs
     */
    public Context parse(final String filename) throws IOException {
<span class="fc" id="L846">        this.init();</span>
<span class="fc" id="L847">        Serializer.getInstance().parse(this, Factory.getInstance(), filename);</span>
<span class="fc" id="L848">        return this;</span>
    }

    /**
     * Removes from this component reducible attributes.
     *
     * Reducible attributes are attributes equivalent by closure to others attributes.
     * They are computed by `getReducibleElements` od `ClosureSystem` in O(|A|^3|O|)
     *
     * @return  the set of reducibles removed attributes, with their equivalent attributes
     */
    public TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; attributesReduction() {
        // compute the reducible elements
<span class="fc" id="L861">        TreeMap red = this.getReducibleElements();</span>
        // remove the reducible elements from the attributes set
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">        for (Object att : red.keySet()) {</span>
<span class="nc" id="L864">            this.removeFromAttributes((Comparable) att);</span>
<span class="nc" id="L865">        }</span>
<span class="fc" id="L866">        return red;</span>
    }

    /**
     * Removes from this component reducible observations.
     *
     * Reducible observations are attributes equivalent by closure to others observations.
     * They are computed by `getReducibleElements` od `ClosureSystem`
     * applied on the reverse context in O(|O|^3|A|)
     *
     * @return  the set of reducibles removed attributes, with their equivalent attributes
     */
    public TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; observationsReduction() {
        // compute the reducible elements of the reverse context
<span class="fc" id="L880">        this.reverse();</span>
<span class="fc" id="L881">        TreeMap red = this.getReducibleElements();</span>
<span class="fc" id="L882">        this.reverse();</span>
        // remove the reducible elements from the observations set
<span class="fc bfc" id="L884" title="All 2 branches covered.">        for (Object att : red.keySet()) {</span>
<span class="fc" id="L885">            this.removeFromObservations((Comparable) att);</span>
<span class="fc" id="L886">        }</span>
<span class="fc" id="L887">        return red;</span>
    }

    /**
     * Removes from this component reducible attributes and observations.
     *
     * They are computed by `attributesReduction` then
     * `observationsReduction` in O(|A|^3|O|+|O|^3|A|)
     *
     * @return  the set of reducibles removed attributes and observations with their equivalent elements
     */
    public TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; reduction() {
<span class="fc" id="L899">        TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; red = this.attributesReduction();</span>
<span class="fc" id="L900">        red.putAll(this.observationsReduction());</span>
<span class="fc" id="L901">        return red;</span>
    }

    /**
     * Reverses this component by replacing attributes by observations and observations by
     * attributes. Intent and extent are exchanged in the same way.
     */
    public void reverse() {
<span class="fc" id="L909">        TreeSet&lt;Comparable&gt; tmp = this.attributes;</span>
<span class="fc" id="L910">        this.attributes = this.observations;</span>
<span class="fc" id="L911">        this.observations = tmp;</span>
<span class="fc" id="L912">        TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; sauv = this.intent;</span>
<span class="fc" id="L913">        this.intent = this.extent;</span>
<span class="fc" id="L914">        this.extent = sauv;</span>
<span class="fc" id="L915">    }</span>

    /**
     * Return a new reversed Context.
     *
     * @return  a new reversed Context
     */
    public Context getReverseContext() {
<span class="fc" id="L923">        Context context = new Context(this);</span>
<span class="fc" id="L924">        context.reverse();</span>
<span class="fc" id="L925">        context.setBitSets();</span>
<span class="fc" id="L926">        return context;</span>
    }

    /**
     * Returns the arrow-closed subcontext of this component containing obs.
     *
     * A sub-context (H,N) of (G,M) is arrow-closed if :
     * 1. For all h in H, h uparrow m implies m in N and
     * 2. For all n in N, g downarrow n implies g in H
     *
     * @param obs set of observations to keep
     * @return the arrow-closed subcontext of this component containing obs.
     */
    public Context arrowClosureObject(TreeSet&lt;Comparable&gt; obs) {
<span class="fc" id="L940">        ConceptLattice cl = this.getReverseContext().conceptLattice(true); // Where is bug with it ^^</span>
<span class="fc" id="L941">        ArrowRelation ar = cl.getArrowRelation();</span>
        /*
        WARNING : this component contains &quot;observations&quot; and &quot;attributes&quot;
        whereas following contexts, down and up, are made of concept.
        */
<span class="fc" id="L946">        Context down = ar.getDoubleDownArrowTable();</span>
<span class="fc" id="L947">        Context up = ar.getDoubleUpArrowTable();</span>
<span class="fc" id="L948">        Context ctx = new Context();</span>
<span class="fc" id="L949">        ctx.addAllToObservations(obs);</span>
<span class="fc" id="L950">        int sizeObs = ctx.getObservations().size();</span>
<span class="fc" id="L951">        int sizeAttr = ctx.getAttributes().size();</span>
<span class="fc" id="L952">        int prevObs = 0;</span>
<span class="fc" id="L953">        int prevAttr = 0;</span>
<span class="fc bfc" id="L954" title="All 4 branches covered.">        while ((prevObs &lt; sizeObs) || (prevAttr &lt; sizeAttr)) {</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">            for (Comparable o : ctx.getObservations()) {</span>
                // Concept corresponding to observation o
<span class="fc" id="L957">                TreeSet&lt;Comparable&gt; setBo = this.getIntent(o);</span>
<span class="fc" id="L958">                TreeSet&lt;Comparable&gt; setAo = this.getExtent(setBo);</span>
<span class="fc" id="L959">                Concept cptO = new Concept(setAo, setBo);</span>
<span class="fc" id="L960">                TreeSet&lt;Comparable&gt; attrUp = up.getIntent(cl.getNode(cptO)); // Doesn't work with up.getIntent(cptO) ...</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                for (Comparable a : this.getAttributes()) { // NOT GOOD for complexity :-(</span>
                    // Try to find attributes in up-arrow relation
<span class="fc" id="L963">                    TreeSet&lt;Comparable&gt; setAa = this.getExtent(a);</span>
<span class="fc" id="L964">                    TreeSet&lt;Comparable&gt; setBa = this.getIntent(setAa);</span>
<span class="fc" id="L965">                    Concept cptA = new Concept(setAa, setBa); // Concept corresponding to attribute a</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">                    if (attrUp.contains(cl.getNode(cptA))) {</span>
<span class="fc" id="L967">                        ctx.addToAttributes(a);</span>
                    }
<span class="fc" id="L969">                }</span>
<span class="fc" id="L970">            }</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">            for (Comparable a : ctx.getAttributes()) {</span>
                // Concept corresponding to observation a
<span class="fc" id="L973">                TreeSet&lt;Comparable&gt; setAa = this.getExtent(a);</span>
<span class="fc" id="L974">                TreeSet&lt;Comparable&gt; setBa = this.getIntent(setAa);</span>
<span class="fc" id="L975">                Concept cptA = new Concept(setAa, setBa);</span>
<span class="fc" id="L976">                TreeSet&lt;Comparable&gt; obsDown = down.getExtent(cl.getNode(cptA));</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">                for (Comparable o : this.getObservations()) {</span>
                    // Try to find attributes in down-arrow relation
<span class="fc" id="L979">                    TreeSet&lt;Comparable&gt; setBo = this.getIntent(o);</span>
<span class="fc" id="L980">                    TreeSet&lt;Comparable&gt; setAo = this.getExtent(setBo);</span>
<span class="fc" id="L981">                    Concept cptO = new Concept(setAo, setBo); // Concept corresponding to attribute o</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">                    if (obsDown.contains(cl.getNode(cptO))) {</span>
<span class="fc" id="L983">                        ctx.addToObservations(o);</span>
                    }
<span class="fc" id="L985">                }</span>
<span class="fc" id="L986">            }</span>
<span class="fc" id="L987">            prevObs = sizeObs;</span>
<span class="fc" id="L988">            prevAttr = sizeAttr;</span>
<span class="fc" id="L989">            sizeObs = ctx.getObservations().size();</span>
<span class="fc" id="L990">            sizeAttr = ctx.getAttributes().size();</span>
        }
<span class="fc" id="L992">        return this.getSubContext(ctx.getObservations(), ctx.getAttributes());</span>
    }
    /**
     * Returns the arrow-closed subcontext of this component containing attr.
     *
     * A sub-context (H,N) of (G,M) is arrow-closed if :
     * 1. For all h in H, h uparrow m implies m in N and
     * 2. For all n in N, g downarrow n implies g in H
     *
     * @param attr set of attributes to keep
     * @return the arrow-closed subcontext of this component containing attr.
     */
    public Context arrowClosureAttribute(TreeSet&lt;Comparable&gt; attr) {
<span class="fc" id="L1005">        ConceptLattice cl = this.getReverseContext().conceptLattice(true); // Where is bug with it ^^</span>
<span class="fc" id="L1006">        ArrowRelation ar = cl.getArrowRelation();</span>
<span class="fc" id="L1007">        Context down = ar.getDoubleDownArrowTable();</span>
<span class="fc" id="L1008">        Context up = ar.getDoubleUpArrowTable();</span>
<span class="fc" id="L1009">        Context ctx = new Context();</span>
<span class="fc" id="L1010">        ctx.addAllToAttributes(attr);</span>
<span class="fc" id="L1011">        int sizeObs = ctx.getObservations().size();</span>
<span class="fc" id="L1012">        int sizeAttr = ctx.getAttributes().size();</span>
<span class="fc" id="L1013">        int prevObs = 0;</span>
<span class="fc" id="L1014">        int prevAttr = 0;</span>
<span class="fc bfc" id="L1015" title="All 4 branches covered.">        while ((prevObs &lt; sizeObs) || (prevAttr &lt; sizeAttr)) {</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">            for (Comparable a : ctx.getAttributes()) {</span>
                // Concept corresponding to observation a
<span class="fc" id="L1018">                TreeSet&lt;Comparable&gt; setAa = this.getExtent(a);</span>
<span class="fc" id="L1019">                TreeSet&lt;Comparable&gt; setBa = this.getIntent(setAa);</span>
<span class="fc" id="L1020">                Concept cptA = new Concept(setAa, setBa);</span>
<span class="fc" id="L1021">                TreeSet&lt;Comparable&gt; obsDown = down.getExtent(cl.getNode(cptA));</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                for (Comparable o : this.getObservations()) {</span>
                    // Try to find attributes in down-arrow relation
<span class="fc" id="L1024">                    TreeSet&lt;Comparable&gt; setBo = this.getIntent(o);</span>
<span class="fc" id="L1025">                    TreeSet&lt;Comparable&gt; setAo = this.getExtent(setBo);</span>
<span class="fc" id="L1026">                    Concept cptO = new Concept(setAo, setBo); // Concept corresponding to attribute o</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">                    if (obsDown.contains(cl.getNode(cptO))) {</span>
<span class="fc" id="L1028">                        ctx.addToObservations(o);</span>
                    }
<span class="fc" id="L1030">                }</span>
<span class="fc" id="L1031">            }</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">            for (Comparable o : ctx.getObservations()) {</span>
                // Concept corresponding to observation o
<span class="fc" id="L1034">                TreeSet&lt;Comparable&gt; setBo = this.getIntent(o);</span>
<span class="fc" id="L1035">                TreeSet&lt;Comparable&gt; setAo = this.getExtent(setBo);</span>
<span class="fc" id="L1036">                Concept cptO = new Concept(setAo, setBo);</span>
<span class="fc" id="L1037">                TreeSet&lt;Comparable&gt; attrUp = up.getIntent(cl.getNode(cptO)); // Doesn't work with up.getIntent(cptO) ...</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">                for (Comparable a : this.getAttributes()) { // NOT GOOD for complexity :-(</span>
                    // Try to find attributes in up-arrow relation
<span class="fc" id="L1040">                    TreeSet&lt;Comparable&gt; setAa = this.getExtent(a);</span>
<span class="fc" id="L1041">                    TreeSet&lt;Comparable&gt; setBa = this.getIntent(setAa);</span>
<span class="fc" id="L1042">                    Concept cptA = new Concept(setAa, setBa); // Concept corresponding to attribute a</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">                    if (attrUp.contains(cl.getNode(cptA))) {</span>
<span class="fc" id="L1044">                        ctx.addToAttributes(a);</span>
                    }
<span class="fc" id="L1046">                }</span>
<span class="fc" id="L1047">            }</span>
<span class="fc" id="L1048">            prevObs = sizeObs;</span>
<span class="fc" id="L1049">            prevAttr = sizeAttr;</span>
<span class="fc" id="L1050">            sizeObs = ctx.getObservations().size();</span>
<span class="fc" id="L1051">            sizeAttr = ctx.getAttributes().size();</span>
        }
<span class="fc" id="L1053">        return this.getSubContext(ctx.getObservations(), ctx.getAttributes());</span>
    }
    /* --------------- IMPLEMENTATION OF CLOSURE SYSTEM ABSTRACT METHODS ------------ */
    /* --------------- AND CONCEPT LATTICE GENERATION------------ */

    /**
     * Returns the set of attributes as elements set used by the lattice generator abstract class
     * to generate closed set lattice on attributes. The closed set lattice on abservations can
     * be otained using the reverse method of this class.
     *
     * @return  the set of attributes
     */
    @Override
    public TreeSet&lt;Comparable&gt; getSet() {
<span class="fc" id="L1067">        return this.attributes;</span>
    }

    /**
     * Builds the closure of a set X of attributes.
     *
     * The closure corresponds to the maximal set of attributes having the
     * same intent as the specified one.
     *
     * This treatment is performed in O(|A||O|)
     *
     * @param   set  a TreeSet of indexed elements
     *
     * @return  the closure of the set for this component
     */
    @Override
    public TreeSet&lt;Comparable&gt; closure(TreeSet&lt;Comparable&gt; set) {
<span class="fc" id="L1084">        return this.getIntent(this.getExtent(set));</span>
    }

    /**
     * Returns the set of union of observations that are intent with one of attributes of the specified set.
     *
     * @param   set  a specified set
     *
     * @return  the set of union of observations
     */
      public TreeSet&lt;Comparable&gt; getExtentUnion(TreeSet&lt;Comparable&gt; set) {
<span class="nc" id="L1095">        TreeSet&lt;Comparable&gt; ext = new TreeSet();</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        for (Comparable att : set) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            for (Comparable obs : this.getExtent(att)) {</span>
<span class="nc bnc" id="L1098" title="All 4 branches missed.">                if (this.containAsExtent(att, obs) &amp;&amp; !ext.contains(obs)) {</span>
<span class="nc" id="L1099">                    ext.add(obs);</span>
                }
<span class="nc" id="L1101">            }</span>
<span class="nc" id="L1102">        }</span>
<span class="nc" id="L1103">        return ext;</span>
    }

    /**
     * Builds the inverse of the closure operator of a set of observations.
     *
     * The inverse closure corresponds to the maximal set of observations having the
     * same intent as the specified one.
     * This treatment is performed in O(|A||O|)
     *
     * @param   set  a TreeSet of indexed elements
     *
     * @return  the closure of the set for this component
     */
    public ComparableSet inverseClosure(ComparableSet set) {
<span class="nc" id="L1118">        return new ComparableSet(this.getExtent(this.getIntent((TreeSet) set)));</span>
    }

    /**
     * Returns the concept lattice of this component.
     *
     * A true value of the boolean `diagram` indicates that the
     * Hasse diagramm of the lattice is computed (i.e. it is transitively reduced),
     * whereas a false value indicates that the lattice is transitively closed
     *
     * The closed set lattice is first generated using
     * `ConceptLattice closedSetLattice (boolean  diagram)`
     * Then, nodes of the lattice are completed as concepts.
     *
     * @param   diagram  a boolean indicating if the Hasse diagramm of the lattice is computed or not.
     *
     * @return  The concept lattice induced by this component
     */
    public ConceptLattice conceptLattice(boolean  diagram) {
<span class="fc" id="L1137">        ConceptLattice csl = this.closedSetLattice(diagram);</span>
        // TreeMap&lt;Concept, Concept&gt; nodes = new TreeMap&lt;Concept, Concept&gt;();
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L1140">             Concept cl = (Concept) n;</span>
<span class="fc" id="L1141">             cl.putSetB(new ComparableSet(this.getExtent(cl.getSetA())));</span>
<span class="fc" id="L1142">        }</span>
<span class="fc" id="L1143">        return csl;</span>
    }
    /**
     * Reccursively generates nodes of the product lattice.
     *
     * @param c couple to be completed
     * @param clParts list of last context to deal with
     * @return a list of nodes to add to the product.
     */
    private ArrayList&lt;Couple&gt; reccursiveGenProd(Couple c, LinkedList&lt;ConceptLattice&gt; clParts) {
<span class="fc" id="L1153">        LinkedList&lt;ConceptLattice&gt; copy = (LinkedList&lt;ConceptLattice&gt;) clParts.clone();</span>
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">        if (copy.isEmpty()) {</span>
<span class="fc" id="L1155">            ArrayList&lt;Couple&gt; result = new ArrayList&lt;Couple&gt;();</span>
<span class="fc" id="L1156">            result.add(c);</span>
<span class="fc" id="L1157">            return result;</span>
        } else {
<span class="nc" id="L1159">            ConceptLattice cl = (ConceptLattice) copy.poll();</span>
<span class="nc" id="L1160">            ArrayList&lt;Couple&gt; nodes = new ArrayList&lt;Couple&gt;();</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            for (Node n : cl.getNodes()) {</span>
<span class="nc" id="L1162">                ArrayList&lt;Concept&gt; listCopy = new ArrayList&lt;Concept&gt;();</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                for (Concept cpt : (ArrayList&lt;Concept&gt;) c.getLeft()) {</span>
<span class="nc" id="L1164">                    listCopy.add(cpt);</span>
<span class="nc" id="L1165">                }</span>
<span class="nc" id="L1166">                Couple coupleCopy = new Couple(listCopy, c.getRight());</span>
<span class="nc" id="L1167">                ((ArrayList&lt;Concept&gt;) coupleCopy.getLeft()).add((Concept) n);</span>
<span class="nc" id="L1168">                nodes.addAll(reccursiveGenProd(coupleCopy, copy));</span>
<span class="nc" id="L1169">            }</span>
<span class="nc" id="L1170">            return nodes;</span>
        }
    }
    /**
     * Returns the concept lattice of this component represented as a subdirect product of its irreductibles components.
     *
     * WARNING : Context MUST BE REDUCED !
     *
     * @return concept Lattice of this component represented as a subdirect product of its irreductibles components.
     */
    public Lattice subDirectDecomposition() {
        // First, compute 1-generated arrow-closed subcontextes
<span class="fc" id="L1182">        ArrayList&lt;Context&gt; parts = new ArrayList&lt;Context&gt;();</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        for (Comparable o : this.getObservations()) {</span>
<span class="fc" id="L1184">            TreeSet&lt;Comparable&gt; setO = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L1185">            setO.add(o);</span>
<span class="fc" id="L1186">            parts.add(this.arrowClosureObject(setO));</span>
<span class="fc" id="L1187">        }</span>
        // Second, remove contexts contained in other. They are dispendable.
        // Remove first all contexts that appeared at least twice.
<span class="fc" id="L1190">        ArrayList&lt;Context&gt; single = new ArrayList&lt;Context&gt;();</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        for (int i = 0; i &lt; parts.size(); i++) {</span>
<span class="fc" id="L1192">            boolean containedNext = false;</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">            for (int j = i + 1; j &lt; parts.size(); j++) {</span>
<span class="pc bpc" id="L1194" title="4 of 10 branches missed.">                containedNext = containedNext || (parts.get(i).containsAllObservations(parts.get(j).getObservations())</span>
                        &amp;&amp; parts.get(j).containsAllObservations(parts.get(i).getObservations())
                        &amp;&amp; parts.get(i).containsAllAttributes(parts.get(j).getAttributes())
                        &amp;&amp; parts.get(j).containsAllAttributes(parts.get(i).getAttributes()));
            }
<span class="fc bfc" id="L1199" title="All 2 branches covered.">            if (!containedNext) {</span>
<span class="fc" id="L1200">                single.add(parts.get(i));</span>
            }
        }
<span class="fc" id="L1203">        parts = single;</span>
<span class="fc" id="L1204">        ArrayList&lt;Context&gt; toBeRemoved = new ArrayList&lt;Context&gt;();</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">        for (Context remove : parts) {</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">            for (Context test : parts) {</span>
<span class="pc bpc" id="L1207" title="5 of 6 branches missed.">                if ((parts.indexOf(test) != parts.indexOf(remove))</span>
                        &amp;&amp; (test.containsAllObservations(remove.getObservations()))
                        &amp;&amp; (test.containsAllAttributes(remove.getAttributes()))) {
<span class="nc" id="L1210">                    toBeRemoved.add(remove);</span>
                }
<span class="fc" id="L1212">            }</span>
<span class="fc" id="L1213">        }</span>
<span class="fc" id="L1214">        parts.removeAll(toBeRemoved);</span>
        // Third, compute the product but can't use LatticeFactory.product :-(
        /*
        Content of each node is of the following form :
        1. They are Couple
        2. Left part is an ArrayList corresponding to the terms of the product
        3. Right part is a boolean, true if the node is inside the sub-product.
        Thus we have : the full product, and nodes of the subproduct marked
        */
        // First compute all nodes of the product
<span class="fc" id="L1224">        LinkedList&lt;ConceptLattice&gt; clParts = new LinkedList&lt;ConceptLattice&gt;();</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">        for (Context ctx : parts) {</span>
<span class="fc" id="L1226">            clParts.add(ctx.conceptLattice(true));</span>
<span class="fc" id="L1227">        }</span>
<span class="fc" id="L1228">        Lattice prod = new Lattice();</span>
        // Computes nodes
<span class="fc" id="L1230">        ArrayList&lt;Couple&gt; nodes = new ArrayList&lt;Couple&gt;();</span>
<span class="fc" id="L1231">        LinkedList&lt;ConceptLattice&gt; copy = (LinkedList&lt;ConceptLattice&gt;) clParts.clone();</span>
<span class="fc" id="L1232">        ConceptLattice firstCL = (ConceptLattice) copy.poll();</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        for (Node n : firstCL.getNodes()) {</span>
<span class="fc" id="L1234">            Couple c = new Couple(new ArrayList&lt;Concept&gt;(), false);</span>
<span class="fc" id="L1235">            ArrayList&lt;Concept&gt; prodCPT = new ArrayList&lt;Concept&gt;();</span>
<span class="fc" id="L1236">            prodCPT.add((Concept) n);</span>
<span class="fc" id="L1237">            c.setLeft(prodCPT);</span>
<span class="fc" id="L1238">            nodes.addAll(reccursiveGenProd(c, copy));</span>
<span class="fc" id="L1239">        }</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">        for (Couple c : nodes) {</span>
<span class="fc" id="L1241">            prod.addNode(new Node(c));</span>
<span class="fc" id="L1242">        }</span>
        // Add edges
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        for (Node from : prod.getNodes()) {</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">            for (Node to : prod.getNodes()) {</span>
<span class="fc" id="L1246">                Couple contentFrom = (Couple) from.getContent();</span>
<span class="fc" id="L1247">                Couple contentTo = (Couple) to.getContent();</span>
<span class="fc" id="L1248">                boolean haveEdge = true;</span>
<span class="fc" id="L1249">                boolean equals = true;</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">                for (int i = 0; i &lt; clParts.size(); i++) { // clParts.size() is the number of factor</span>
<span class="fc" id="L1251">                    Concept cptFrom = ((ArrayList&lt;Concept&gt;) contentFrom.getLeft()).get(i);</span>
<span class="fc" id="L1252">                    Concept cptTo = ((ArrayList&lt;Concept&gt;) contentTo.getLeft()).get(i);</span>
<span class="pc bpc" id="L1253" title="1 of 4 branches missed.">                    equals = equals &amp;&amp; cptFrom.equals(cptTo);</span>
<span class="pc bpc" id="L1254" title="1 of 6 branches missed.">                    haveEdge = haveEdge &amp;&amp; (clParts.get(i).containsEdge(cptFrom, cptTo) || cptFrom.equals(cptTo));</span>
                }
<span class="fc bfc" id="L1256" title="All 4 branches covered.">                if (haveEdge &amp;&amp; !equals) {</span>
<span class="fc" id="L1257">                    prod.addEdge(from, to);</span>
                }
<span class="fc" id="L1259">            }</span>
<span class="fc" id="L1260">        }</span>
<span class="fc" id="L1261">        prod.transitiveReduction();</span>
        // Last, identify the sub-product, e.g. nodes of this component in the product.
        // In the subdirect decomposition, if (A,B) is a concept then (A \cap H,B \cap N) also.
        // Transform nodes of the original lattice into nodes of the subproduct lattice and mark them
<span class="fc" id="L1265">        ConceptLattice cl = this.conceptLattice(true);</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">        for (Node cpt : cl.getNodes()) {</span>
            // Compute cpt representation in prod
<span class="fc" id="L1268">            ArrayList&lt;Concept&gt; subCpt = new ArrayList&lt;Concept&gt;();</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">            for (int i = 0; i &lt; parts.size(); i++) {</span>
<span class="fc" id="L1270">                Context ctx = parts.get(i);</span>
<span class="fc" id="L1271">                ConceptLattice term = clParts.get(i);</span>
<span class="fc" id="L1272">                ComparableSet setA = new ComparableSet();</span>
<span class="fc" id="L1273">                setA.addAll(((Concept) cpt).getSetA());</span>
<span class="fc" id="L1274">                ComparableSet setB = new ComparableSet();</span>
<span class="fc" id="L1275">                setB.addAll(((Concept) cpt).getSetB());</span>
<span class="fc" id="L1276">                setA.retainAll(ctx.getAttributes());</span>
<span class="fc" id="L1277">                setB.retainAll(ctx.getObservations());</span>
<span class="fc" id="L1278">                subCpt.add(term.getConcept((ComparableSet) setA, (ComparableSet) setB));</span>
            }
            // Check if cpt is in prod
<span class="fc bfc" id="L1281" title="All 2 branches covered.">            for (Node nodeProd : prod.getNodes()) {</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">                if (((Couple) nodeProd.getContent()).getLeft().equals(subCpt)) {</span>
<span class="fc" id="L1283">                    ((Couple) nodeProd.getContent()).setRight(true);</span>
                }
<span class="fc" id="L1285">            }</span>
<span class="fc" id="L1286">        }</span>
<span class="fc" id="L1287">        return prod;</span>
    }
    /**
     * Returns the lattice of this component.
     *
     * @return  The lattice induced by this component
     */
    public ConceptLattice lattice() {
<span class="fc" id="L1295">        return this.conceptLattice(true);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>