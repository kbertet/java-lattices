<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DAGraph.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">fr.kbertet.dgraph</a> &gt; <span class="el_source">DAGraph.java</span></div><h1>DAGraph.java</h1><pre class="source lang-java linenums">package fr.kbertet.dgraph;

/*
 * DAGraph.java
 *
 * Copyright: 2010-2014 Karell Bertet, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 */

import java.util.ArrayList;
import java.util.TreeMap;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.Set;

/**
 * This class extends the representation of a directed graph given by class
 * {@link DGraph} for directed acyclic graph (DAG).
 *
 * The main property of a directed acyclic graph is to be a partially ordered set (poset) when
 * transitively closed, and a Hasse diagram when transitively reduced.
 *
 * This property is not ensured for components of this class because it would require a
 * checking treatment over the graph whenever a new edge or node is added.
 * However, this property can be explicitely ckecked using method
 * {@link #isAcyclic}.
 *
 * This class provides methods implementing classical operation on a directed acyclic graph:
 * minorants and majorants, filter and ideal, transitive reduction, ideal lattice, ...
 *
 * This class also provides a static method randomly generating a directed acyclic graph,
 * and a static method generating the graph of divisors.
 *
 * ![DAGraph](DAGraph.png)
 *
 * @todo  Do we forbid to add an edge that breaks acyclic property by verifying that the destination node has no successors?
 *        May be a DAGraph could contain a DGraph and export only interesting method by proxy
 *
 * @uml DAGraph.png
 * !include resources/fr/kbertet/dgraph/DAGraph.iuml
 * !include resources/fr/kbertet/dgraph/DGraph.iuml
 * !include resources/fr/kbertet/dgraph/Edge.iuml
 * !include resources/fr/kbertet/dgraph/Node.iuml
 *
 * hide members
 * show DAGraph members
 * class DAGraph #LightCyan
 * title DAGraph UML graph
 */
public class DAGraph extends DGraph {

    /**
     * Constructs a new DAG with an empty set of node.
     */
    public DAGraph() {
<span class="fc" id="L60">        super();</span>
<span class="fc" id="L61">    }</span>

    /**
     * Constructs this component with the specified set of nodes,
     * and empty treemap of successors and predecessors.
     *
     * @param   set  the set of nodes
     */
    public DAGraph(final Set&lt;Node&gt; set) {
<span class="fc" id="L70">        super(set);</span>
<span class="fc" id="L71">    }</span>

    /**
     * Constructs this component as a copy of the specified directed graph.
     *
     * Acyclic property is checked for the specified DAG.
     * When not verified, this component is construct with the same set of nodes but with no edges.
     *
     * @param   graph  the DGraph to be copied
     */
    public DAGraph(final DGraph graph) {
<span class="fc" id="L82">        super(graph);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (this.isAcyclic()) {</span>
<span class="fc" id="L84">            this.reflexiveReduction();</span>
        } else {
<span class="fc" id="L86">            TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; successors = new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;();</span>
<span class="fc" id="L87">            TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; predecessors = new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            for (Node node : this.getNodes()) {</span>
<span class="fc" id="L89">                successors.put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="fc" id="L90">                predecessors.put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="fc" id="L91">            }</span>
<span class="fc" id="L92">            this.setSuccessors(successors);</span>
<span class="fc" id="L93">            this.setPredecessors(predecessors);</span>
        }
<span class="fc" id="L95">    }</span>

    /* --------------- DAG HANDLING METHODS ------------ */

    /**
     * Returns the minimal element of this component.
     *
     * @return  the minimal element
     */
    public SortedSet&lt;Node&gt; min() {
<span class="fc" id="L105">        return this.getSinks();</span>
    }

    /**
     * Returns the maximal element of this component.
     *
     * @return  the maximal element
     */
    public SortedSet&lt;Node&gt; max() {
<span class="fc" id="L114">        return this.getWells();</span>
    }

    /**
     * Returns the set of majorants of the specified node.
     *
     * Majorants of a node are its successors in the transitive closure
     *
     * @param   node  the specified node
     *
     * @return  the set of majorants
     */
    public SortedSet&lt;Node&gt; majorants(final Node node) {
<span class="fc" id="L127">        DAGraph graph = new DAGraph(this);</span>
<span class="fc" id="L128">        graph.transitiveClosure();</span>
<span class="fc" id="L129">        return graph.getSuccessorNodes(node);</span>
    }

    /**
     * Returns the set of minorants of the specified node.
     *
     * Minorants of a node are its predecessors in the transitive closure
     *
     * @param   node  the specified node
     *
     * @return  the set of minorants
     */
    public SortedSet&lt;Node&gt; minorants(final Node node) {
<span class="fc" id="L142">        DAGraph graph = new DAGraph(this);</span>
<span class="fc" id="L143">        graph.transitiveClosure();</span>
<span class="fc" id="L144">        return graph.getPredecessorNodes(node);</span>
    }

    /**
     * Returns the subgraph induced by the specified node and its successors
     * in the transitive closure.
     *
     * @param   node  the specified node
     *
     * @return  the subgraph
     */
    public DAGraph filter(final Node node) {
<span class="fc" id="L156">        TreeSet&lt;Node&gt; set = new TreeSet&lt;Node&gt;(this.majorants(node));</span>
<span class="fc" id="L157">        set.add(node);</span>
<span class="fc" id="L158">        return this.getSubgraphByNodes(set);</span>
    }

    /**
     * Returns the subgraph induced by the specified node and its predecessors
     * in the transitive closure.
     *
     * @param   node the specified node
     *
     * @return  the subgraph
     */
    public DAGraph ideal(final Node node) {
<span class="fc" id="L170">        TreeSet&lt;Node&gt; set = new TreeSet&lt;Node&gt;(this.minorants(node));</span>
<span class="fc" id="L171">        set.add(node);</span>
<span class="fc" id="L172">        return this.getSubgraphByNodes(set);</span>
    }

    /**
     * Returns the subgraph of this component induced by the specified set of nodes.
     *
     * The subgraph only contains nodes of the specified set that also are in this component.
     *
     * @param   nodes  The set of nodes
     *
     * @return  The subgraph
     */
    public DAGraph getSubgraphByNodes(final Set&lt;Node&gt; nodes) {
<span class="fc" id="L185">        DGraph tmp = new DGraph(this);</span>
<span class="fc" id="L186">        tmp.transitiveClosure();</span>
<span class="fc" id="L187">        DGraph sub = tmp.getSubgraphByNodes(nodes);</span>
<span class="fc" id="L188">        DAGraph sub2 = new DAGraph(sub);</span>
<span class="fc" id="L189">        sub2.transitiveReduction();</span>
<span class="fc" id="L190">        return sub2;</span>
    }

    /* --------------- DAG TREATMENT METHODS ------------ */

    /**
     * Computes the transitive reduction of this component.
     *
     * The transitive reduction is not uniquely defined only when the acyclic property
     * is verified. In this case, it corresponds to the Hasse diagram of the DAG.
     *
     * This method is an implementation of the Goralcikova-Koubeck
     * algorithm that can also compute the transitive closure.
     * This tratment is performed in O(n+nm_r+nm_c),
     * where n corresponds to the number of nodes,
     * m_r to the numer of edges in the transitive closure,
     * and m_r the number of edges in the transitive reduction.
     *
     * @return  the number of added edges
     */
    public int transitiveReduction() {

        // copy this component in a new DAG graph
<span class="fc" id="L213">        DAGraph graph = new DAGraph(this);</span>
<span class="fc" id="L214">        graph.reflexiveReduction();</span>
        // initalize this component with no edges
<span class="fc" id="L216">        this.setSuccessors(new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;());</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (Node node : this.getNodes()) {</span>
<span class="fc" id="L218">            this.getSuccessors().put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">        this.setPredecessors(new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;());</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (Node node : this.getNodes()) {</span>
<span class="fc" id="L222">            this.getPredecessors().put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="fc" id="L223">        }</span>
<span class="fc" id="L224">        int number = 0;</span>
        // mark each node to false
<span class="fc" id="L226">        TreeMap&lt;Node, Boolean&gt; mark = new TreeMap&lt;Node, Boolean&gt;();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (Node node : graph.getNodes()) {</span>
<span class="fc" id="L228">            mark.put(node, new Boolean(false));</span>
<span class="fc" id="L229">        }</span>
        // treatment of nodes according to a topological sort
<span class="fc" id="L231">        ArrayList&lt;Node&gt; sort = graph.topologicalSort();</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for (Node x : sort) {</span>
<span class="fc" id="L233">            TreeSet&lt;Node&gt; set = new TreeSet&lt;Node&gt;(graph.getSuccessorNodes(x));</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            while (!set.isEmpty()) {</span>
                // compute the smallest successor y of x according to the topological sort
<span class="fc" id="L236">                int i = 0;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                while (!set.contains(sort.get(i))) {</span>
<span class="fc" id="L238">                    i++;</span>
                }
<span class="fc" id="L240">                Node y = sort.get(i);</span>
                // when y is not not marked, x-&gt;y is a reduced edge
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">                if (y != null &amp;&amp; !mark.get(y).booleanValue()) {</span>
<span class="fc" id="L243">                    this.addEdge(x, y);</span>
<span class="fc" id="L244">                    graph.addEdge(x, y);</span>
                }
<span class="fc bfc" id="L246" title="All 2 branches covered.">                for (Node z : graph.getSuccessorNodes(y)) {</span>
                    // treatment of z when not marked
<span class="fc bfc" id="L248" title="All 2 branches covered.">                    if (!mark.get(z).booleanValue()) {</span>
<span class="fc" id="L249">                        mark.put(z, new Boolean(true));</span>
<span class="fc" id="L250">                        graph.addEdge(x, z);</span>
<span class="fc" id="L251">                        number++;</span>
<span class="fc" id="L252">                        set.add(z);</span>
                    }
<span class="fc" id="L254">                }</span>
<span class="fc" id="L255">                set.remove(y);</span>
<span class="fc" id="L256">            }</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            for (Node y : graph.getSuccessorNodes(x)) {</span>
<span class="fc" id="L258">                mark.put(y, new Boolean(false));</span>
<span class="fc" id="L259">            }</span>
<span class="fc" id="L260">        }</span>
<span class="fc" id="L261">        return number;</span>
    }

   /**
    * Computes the transitive closure of this component.
    *
    * This method overlaps the computation of the transitive closure for directed graph
    * in class {@link DGraph} with an implementation of the Goralcikova-Koubeck
    * algorithm dedicated to acyclic directed graph. This algorithm can also compute the
    * transitive reduction of a directed acyclic graph.
    *
    * This treatment is performed in O(n+nm_r+nm_c), where n corresponds to the number of nodes,
    * m_r to the numer of edges in the transitive closure,
    * and m_r the number of edges in the transitive reduction.
    *
    * @return  the number of added edges
    */
   public int transitiveClosure() {
<span class="fc" id="L279">        int number = 0;</span>
        // mark each node to false
<span class="fc" id="L281">        TreeMap&lt;Node, Boolean&gt; mark = new TreeMap&lt;Node, Boolean&gt;();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        for (Node node : this.getNodes()) {</span>
<span class="fc" id="L283">            mark.put(node, new Boolean(false));</span>
<span class="fc" id="L284">        }</span>
        // treatment of nodes according to a topological sort
<span class="fc" id="L286">        ArrayList&lt;Node&gt; sort = this.topologicalSort();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (Node x : sort) {</span>
<span class="fc" id="L288">            TreeSet&lt;Node&gt; set = new TreeSet&lt;Node&gt;(this.getSuccessorNodes(x));</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            while (!set.isEmpty()) {</span>
                // compute the smallest successor y of x according to the topological sort
<span class="fc" id="L291">                int i = 0;</span>
                do {
<span class="fc" id="L293">                    i++;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">                } while (!set.contains(sort.get(i)));</span>
<span class="fc" id="L295">                Node y = sort.get(i);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                for (Node z : this.getSuccessorNodes(y)) {</span>
                    // treatment of z when not marked
<span class="fc bfc" id="L298" title="All 2 branches covered.">                    if (!mark.get(z).booleanValue()) {</span>
<span class="fc" id="L299">                        mark.put(z, new Boolean(true));</span>
<span class="fc" id="L300">                        this.addEdge(x, z);</span>
<span class="fc" id="L301">                        number++;</span>
<span class="fc" id="L302">                        set.add(z);</span>
                    }
<span class="fc" id="L304">                }</span>
<span class="fc" id="L305">                set.remove(y);</span>
<span class="fc" id="L306">            }</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">            for (Node y : this.getSuccessorNodes(x)) {</span>
<span class="fc" id="L308">                mark.put(y, new Boolean(false));</span>
<span class="fc" id="L309">            }</span>
<span class="fc" id="L310">        }</span>
<span class="fc" id="L311">        return number;</span>
    }

    /* ----------- STATIC GENERATION METHODS ------------- */

    /**
     * Generates the directed asyclic graph (DAG) of divisors for integers
     * included betwwen 2 and the specified value.
     *
     * In this DAG, nodes corresponds to the integers,
     * and there is an edge between two integers if and only if the second one
     * is divisible by the first one.
     *
     * @param   number  the maximal integer
     *
     * @return  the acyclic graph
     */
    public static DAGraph divisors(int number) {
<span class="fc" id="L329">        DAGraph graph = new DAGraph();</span>
        // addition of nodes
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (int i = 2; i &lt;= number; i++) {</span>
<span class="fc" id="L332">            graph.addNode(new Node(new Integer(i)));</span>
        }
        // addition of edges
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (Node from : graph.getNodes()) {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            for (Node to : graph.getNodes()) {</span>
<span class="fc" id="L337">               int v1 = ((Integer) from.getContent()).intValue();</span>
<span class="fc" id="L338">               int v2 = ((Integer) to.getContent()).intValue();</span>
<span class="fc bfc" id="L339" title="All 4 branches covered.">               if (v1 &lt; v2 &amp;&amp; v2 % v1 == 0) {</span>
<span class="fc" id="L340">                   graph.addEdge(from, to);</span>
               }
<span class="fc" id="L342">            }</span>
<span class="fc" id="L343">        }</span>
<span class="fc" id="L344">        return graph;</span>
    }

    /**
     * Generates a random directed and acyclic graph (DAG) of size nodes.
     *
     * @param   size       the number of nodes of the generated graph
     * @param   threshold  the threshold to generate an edge
     *
     * @return  a random acyclic graph
     */
    public static DAGraph random(int size, double threshold) {
<span class="fc" id="L356">        DAGraph graph = new DAGraph();</span>
        // addition of Nodes
<span class="fc bfc" id="L358" title="All 2 branches covered.">        for (int i = 1; i &lt;= size; i++) {</span>
<span class="fc" id="L359">            graph.addNode(new Node(new Integer(i)));</span>
        }
        // addition of edges
<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (Node from : graph.getNodes()) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            for (Node to : graph.getNodes()) {</span>
                // Test to avoid cycles
<span class="fc bfc" id="L365" title="All 2 branches covered.">                if (from.compareTo(to) &gt; 0) {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">                    if (Math.random() &lt; threshold) {</span>
<span class="fc" id="L367">                        graph.addEdge(from, to);</span>
                    }
                }
<span class="fc" id="L370">            }</span>
<span class="fc" id="L371">        }</span>
<span class="fc" id="L372">        return graph;</span>
    }

    /**
     * Generates a random directed graph of size nodes.
     *
     * @param   size  the number of nodes of the generated graph
     *
     * @return  a random acyclic graph
     */
    public static DAGraph random(int size) {
<span class="fc" id="L383">        return random(size, 0.5);</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>