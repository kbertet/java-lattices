<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConceptLattice.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">fr.kbertet.lattice</a> &gt; <span class="el_source">ConceptLattice.java</span></div><h1>ConceptLattice.java</h1><pre class="source lang-java linenums">package fr.kbertet.lattice;

/*
 * ConceptLattice.java
 *
 * Copyright: 2010-2014 Karell Bertet, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 */

import java.util.ArrayList;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

import fr.kbertet.util.ComparableSet;
import fr.kbertet.dgraph.DAGraph;
import fr.kbertet.dgraph.DGraph;
import fr.kbertet.dgraph.Edge;
import fr.kbertet.dgraph.Node;
import fr.kbertet.lattice.io.ConceptLatticeWriter;
import fr.kbertet.lattice.io.ConceptLatticeWriterDot;
import fr.kbertet.lattice.io.ConceptLatticeWriterFactory;

/**
 * This class extends class {@link Lattice} to provide specific methods
 * to manipulate both a concept lattice or a closed set lattice.
 *
 * This class provides methods implementing classical operation on a concept lattice:
 * join and meet reduction, concepts sets reduction, ...
 *
 * This class also provides two static method generating a concept lattice:
 * methods {@link #diagramLattice} and {@link #completeLattice} both computes
 * the closed set lattice of a given closure system.
 * The firt one computes the hasse diagram of the closed set lattice
 * by invoking  method {@link #immediateSuccessors}. This method implements  an
 * adaptation of the well-known Bordat algorithm that also
 * computes the dependance graph of the lattice where at once the minimal generators and the canonical
 * direct basis of the lattice are encoded.
 * The second static method computes the transitively closure of the lattice
 * as the inclusion relation defined on all the closures
 * generated by method {@link ClosureSystem#allClosures} that implements
 * the well-known Wille algorithm.
 *
 * ![ConceptLattice](ConceptLattice.png)
 *
 * @uml ConceptLattice.png
 * !include resources/fr/kbertet/dgraph/DAGraph.iuml
 * !include resources/fr/kbertet/dgraph/DGraph.iuml
 * !include resources/fr/kbertet/dgraph/Edge.iuml
 * !include resources/fr/kbertet/dgraph/Node.iuml
 * !include resources/fr/kbertet/lattice/Lattice.iuml
 * !include resources/fr/kbertet/lattice/ConceptLattice.iuml
 * !include resources/fr/kbertet/lattice/Concept.iuml
 *
 * hide members
 * show ConceptLattice members
 * class ConceptLattice #LightCyan
 * title ConceptLattice UML graph
 */
public class ConceptLattice extends Lattice {
    /*
     * Register dot writer
     */
    static {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (ConceptLatticeWriterFactory.get(&quot;dot&quot;) == null) {</span>
<span class="fc" id="L74">            ConceptLatticeWriterDot.register();</span>
        }
<span class="fc" id="L76">    }</span>

    /* ------------- CONSTRUCTORS ------------------ */

    /**
     * Constructs this component with an empty set of nodes.
     */
    public ConceptLattice() {
<span class="fc" id="L84">        super();</span>
<span class="fc" id="L85">    }</span>

    /**
     * Constructs this component with the specified set of concepts,
     * and empty treemap of successors and predecessors.
     *
     * @param   set  the set of nodes
     */
    public ConceptLattice(TreeSet&lt;Concept&gt; set) {
<span class="fc" id="L94">        super((TreeSet) set);</span>
<span class="fc" id="L95">    }</span>

    /**
     * Constructs this component as a shallow copy of the specified lattice.
     *
     * Concept lattice property is checked for the specified lattice.
     * When not verified, this component is constructed with an empty set of nodes.
     *
     * @param   lattice  the lattice to be copied
     */
    public ConceptLattice(Lattice lattice) {
<span class="fc" id="L106">        super(lattice);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (!this.isConceptLattice()) {</span>
<span class="fc" id="L108">            this.setNodes(new TreeSet&lt;Node&gt;());</span>
<span class="fc" id="L109">            this.setSuccessors(new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;());</span>
<span class="fc" id="L110">            this.setPredecessors(new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;());</span>
        }
<span class="fc" id="L112">    }</span>

    /* ------------- OVERLAPPING METHODS ------------------ */

    /**
     * Adds the specified node to the set of node of this component.
     *
     * In the case where content of this node is not a concept,
     * the node will not be added
     *
     * @param   n  a node
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean addNode(Node n) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (n instanceof Concept) {</span>
<span class="fc" id="L130">            return super.addNode(n);</span>
        } else {
<span class="nc" id="L132">            return false;</span>
        }
    }

    /**
     * Adds the specified edge to this component:
     * `to` is added as a successor of `from`.
     *
     * If the cases where specified nodes don't belongs to the node set,
     * and where nodes don't contains concept as content,
     * then the edge will not be added.
     *
     * @param   from  the node origine of the edge
     * @param   to    the node destination of the edge
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean addEdge(Node from, Node to) {
<span class="pc bpc" id="L152" title="2 of 4 branches missed.">        if ((to instanceof Concept) &amp;&amp; (from instanceof Concept)) {</span>
<span class="fc" id="L153">            return super.addEdge(from, to);</span>
        } else {
<span class="nc" id="L155">            return false;</span>
        }
    }

    /* ------------- CONCEPT LATTICE CHEKING METHOD ------------------ */

    /**
     * Check if nodes of this component are concepts.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean containsConcepts() {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (Node n : this.getNodes()) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (!(n instanceof Concept)) {</span>
<span class="fc" id="L171">                return false;</span>
            }
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">        return true;</span>
    }

    /**
     * Check if this component is a lattice whose nodes are concepts.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean isConceptLattice() {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (!this.isLattice()) {</span>
<span class="nc" id="L186">            return false;</span>
        }
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (!this.containsConcepts()) {</span>
<span class="fc" id="L189">            return false;</span>
        }
<span class="fc" id="L191">        return true;</span>
    }

    /**
     * Check if this component is a lattice whose nodes are concepts with non null set A.
     *
     * @return  a boolean
     *
     * @todo  Comment the return: conception
     */
    public boolean containsAllSetA() {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L203">            return false;</span>
        }
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (Node n : this.getNodes()) {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (!((Concept) n).hasSetA()) {</span>
<span class="nc" id="L207">                return false;</span>
            }
<span class="fc" id="L209">        }</span>
<span class="fc" id="L210">        return true;</span>
    }

    /**
     * Check if this component is a lattice whose nodes are concepts with non null set A.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean containsAllSetB() {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L222">            return false;</span>
        }
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (Node n : this.getNodes()) {</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (!((Concept) n).hasSetB()) {</span>
<span class="fc" id="L226">                return false;</span>
            }
<span class="fc" id="L228">        }</span>
<span class="fc" id="L229">        return true;</span>
    }

    /**
     * Returns a clone of this component composed of a clone of each concept and each edge.
     *
     * @return  a concept lattice
     */
    @Override
    public ConceptLattice clone() {
<span class="fc" id="L239">        ConceptLattice conceptLattice = new ConceptLattice();</span>
<span class="fc" id="L240">        TreeMap&lt;Concept, Concept&gt; copy = new TreeMap&lt;Concept, Concept&gt;();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (Node n : this.getNodes()) {</span>
<span class="fc" id="L242">            Concept c = (Concept) n;</span>
<span class="fc" id="L243">            Concept c2 = c.clone();</span>
<span class="fc" id="L244">            copy.put(c, c2);</span>
<span class="fc" id="L245">            conceptLattice.addNode(c2);</span>
<span class="fc" id="L246">        }</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (Edge ed : this.getEdges()) {</span>
<span class="fc" id="L248">            conceptLattice.addEdge(new Edge(copy.get(ed.getFrom()), copy.get(ed.getTo()), ed.getContent()));</span>
<span class="fc" id="L249">        }</span>
<span class="fc" id="L250">        return conceptLattice;</span>
    }


    /* ------------- SET A AND SET B HANDLING METHOD ------------------ */

    /**
     * Returns concept defined by setA and setB; null if not found.
     *
     * @param setA intent of the concept to find
     * @param setB extent of the concept to find
     * @return concept defined by setA and setB; null if not found.
     */
    public Concept getConcept(ComparableSet setA, ComparableSet setB) {
<span class="fc" id="L264">        SortedSet&lt;Node&gt; setNodes = this.getNodes();</span>
<span class="fc" id="L265">        Concept cpt = null;</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (Node n : setNodes) {</span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">            if ((setA.equals(((Concept) n).getSetA())) &amp;&amp; (setB.equals(((Concept) n).getSetB()))) {</span>
<span class="fc" id="L268">                cpt = (Concept) n;</span>
            }
<span class="fc" id="L270">        }</span>
<span class="fc" id="L271">        return cpt;</span>
    }
    /**
     * Replace set A in each concept of the lattice with the null value.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean removeAllSetA() {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L282">            return false;</span>
        }
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L285">             Concept c = (Concept) n;</span>
<span class="nc" id="L286">             c.putSetA(null);</span>
<span class="nc" id="L287">        }</span>
<span class="fc" id="L288">        return true;</span>
    }

    /**
     * Replace set B in each concept of the lattice with the null value.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean removeAllSetB() {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L300">            return false;</span>
        }
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L303">             Concept c = (Concept) n;</span>
<span class="nc" id="L304">             c.putSetB(null);</span>
<span class="nc" id="L305">        }</span>
<span class="fc" id="L306">        return true;</span>
    }

    /**
     * Replace null set A in each join irreducible concept with a set containing node ident.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean initialiseSetAForJoin() {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L318">            return false;</span>
        }
<span class="fc" id="L320">        TreeSet&lt;Node&gt; joinIrr = this.joinIrreducibles();</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L322">            Concept c = (Concept) n;</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">            if (!c.hasSetA() &amp;&amp; joinIrr.contains(c)) {</span>
<span class="nc" id="L324">                ComparableSet setX = new ComparableSet();</span>
<span class="nc" id="L325">                setX.add(new Integer(c.getIdentifier()));</span>
<span class="nc" id="L326">                c.putSetA(setX);</span>
            }
<span class="nc" id="L328">        }</span>
<span class="fc" id="L329">        return true;</span>
   }

    /**
     * Replace null set B in each meet irreducible concept with a set containing node ident.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean initialiseSetBForMeet() {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L341">            return false;</span>
        }
<span class="fc" id="L343">        TreeSet&lt;Node&gt; meetIrr = this.meetIrreducibles();</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L345">             Concept c = (Concept) n;</span>
<span class="nc bnc" id="L346" title="All 4 branches missed.">             if (!c.hasSetB() &amp;&amp; meetIrr.contains(c)) {</span>
<span class="nc" id="L347">                ComparableSet setX = new ComparableSet();</span>
<span class="nc" id="L348">                setX.add(new Integer(c.getIdentifier()));</span>
<span class="nc" id="L349">                c.putSetB(setX);</span>
             }
<span class="nc" id="L351">         }</span>
<span class="fc" id="L352">        return true;</span>
    }

    /* --------------- INCLUSION REDUCTION METHODS ------------ */

    /**
     * Replaces, if not empty, set A of each concept with the difference between itself
     * and set A of its predecessors;
     * Then replaces, if not empty, set B of each concept by
     * the difference between itself and set B of its successors.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean makeInclusionReduction() {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L369">            return false;</span>
        }
<span class="fc" id="L371">        boolean setA = this.containsAllSetA();</span>
<span class="fc" id="L372">        boolean setB = this.containsAllSetB();</span>
<span class="pc bpc" id="L373" title="3 of 4 branches missed.">        if (!setA &amp;&amp; !setB) {</span>
<span class="nc" id="L374">            return false;</span>
        }
        // makes setA inclusion reduction
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (setA) {</span>
            // computation of an inverse topological sort
<span class="fc" id="L379">            this.transpose();</span>
<span class="fc" id="L380">            ArrayList&lt;Node&gt; sort = this.topologicalSort();</span>
<span class="fc" id="L381">            this.transpose();</span>
            // reduction of set A
<span class="fc bfc" id="L383" title="All 2 branches covered.">            for (Node to : sort) {</span>
<span class="fc" id="L384">                Concept cto = (Concept) to;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                for (Node from : this.getPredecessorNodes(to))  {</span>
<span class="fc" id="L386">                    Concept cfrom = (Concept) from;</span>
<span class="fc" id="L387">                    cto.getSetA().removeAll(cfrom.getSetA());</span>
<span class="fc" id="L388">                }</span>
<span class="fc" id="L389">            }</span>
        }
        // makes setB inclusion reduction
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (setB) {</span>
            // computation of a topological sort
<span class="fc" id="L394">            ArrayList&lt;Node&gt; sort = this.topologicalSort();</span>
            // reduction of set B
<span class="fc bfc" id="L396" title="All 2 branches covered.">            for (Node to : sort) {</span>
<span class="fc" id="L397">                Concept cto  = (Concept) to;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                for (Node from : this.getSuccessorNodes(to))  {</span>
<span class="fc" id="L399">                    Concept cfrom = (Concept) from;</span>
<span class="fc" id="L400">                    cto.getSetB().removeAll(cfrom.getSetB());</span>
<span class="fc" id="L401">                }</span>
<span class="fc" id="L402">            }</span>
        }
<span class="fc" id="L404">        return true;</span>
    }

    /**
     * Replaces set A of each join irreducible node by
     * the difference between itself and set A of the unique predecessor.
     *
     * Others closed sets are replaced by an emptyset.
     *
     * @return  a boolean
     *
     * @todo  Comment the return
     */
    public boolean makeIrreduciblesReduction() {
        // make inclusion reduction
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (this.makeInclusionReduction()) {</span>
            // check if not set A reduced concepts are join irreducibles
            // and if not set B reduced concepts are meet irreducibles
<span class="fc" id="L422">            TreeSet&lt;Node&gt; joinIrr = this.joinIrreducibles();</span>
<span class="fc" id="L423">            TreeSet&lt;Node&gt; meetIrr = this.meetIrreducibles();</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            for (Node n : this.getNodes()) {</span>
<span class="fc" id="L425">                Concept c = (Concept) n;</span>
<span class="pc bpc" id="L426" title="1 of 6 branches missed.">                if (c.hasSetA() &amp;&amp; !c.getSetA().isEmpty() &amp;&amp; !joinIrr.contains(c)) {</span>
<span class="fc" id="L427">                    c.putSetA(new ComparableSet());</span>
                }
<span class="fc bfc" id="L429" title="All 6 branches covered.">                if (c.hasSetB() &amp;&amp; !c.getSetB().isEmpty() &amp;&amp; !meetIrr.contains(c)) {</span>
<span class="fc" id="L430">                    c.putSetB(new ComparableSet());</span>
                }
<span class="fc" id="L432">            }</span>
        }
<span class="fc" id="L434">        return true;</span>
    }

    /**
     * Returns a lattice where edges are valuated by the difference between
     * set A of two adjacent concepts.
     *
     * @return  a boolean
     *
     * @todo  Change comment
     */
    public boolean makeEdgeValuation() {
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L447">            return false;</span>
        }
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        for (Node n1 : this.getNodes()) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            for (Edge ed : this.getSuccessorEdges(n1)) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (!ed.hasContent()) {</span>
<span class="nc" id="L452">                    Node n2 = ed.getTo();</span>
<span class="nc" id="L453">                    TreeSet diff = new TreeSet();</span>
<span class="nc" id="L454">                    diff.addAll(((Concept) n2).getSetA());</span>
<span class="nc" id="L455">                    diff.removeAll(((Concept) n1).getSetA());</span>
<span class="nc" id="L456">                    ed.setContent(diff);</span>
                }
<span class="nc" id="L458">            }</span>
<span class="nc" id="L459">        }</span>
<span class="fc" id="L460">        return true;</span>
    }

    /* --------------- LATTICE GENERATION METHODS ------------ */

    /**
     * Returns a lattice where join irreducibles node's content
     * is replaced by the first element of set A.
     *
     * Other nodes are replaced by a new comparable.
     *
     * @return  a lattice
     */
    public Lattice getJoinReduction() {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L475">            return null;</span>
        }
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (!this.containsAllSetA()) {</span>
<span class="nc" id="L478">            return null;</span>
        }
<span class="fc" id="L480">        Lattice lattice = new Lattice();</span>
        //ConceptLattice csl = new ConceptLattice (this);
<span class="fc" id="L482">        ConceptLattice csl = this.clone();</span>
<span class="fc" id="L483">        csl.makeIrreduciblesReduction();</span>
<span class="fc" id="L484">        TreeSet&lt;Node&gt; joinIrr = csl.joinIrreducibles();</span>
        // addition to lattice of a comparable issued from each reduced closed set
<span class="fc" id="L486">        TreeMap&lt;Node, Node&gt; reduced = new TreeMap&lt;Node, Node&gt;();</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L488">            Concept c = (Concept) n;</span>
            Node nred;
<span class="pc bpc" id="L490" title="1 of 4 branches missed.">            if (c.hasSetA() &amp;&amp; joinIrr.contains(n)) {</span>
<span class="fc" id="L491">                nred = new Node(c.getSetA().first());</span>
            } else {
<span class="fc" id="L493">                nred = new Node();</span>
            }
<span class="fc" id="L495">            reduced.put(n, nred);</span>
<span class="fc" id="L496">        }</span>
        // addtion of nodes to lattice
<span class="fc bfc" id="L498" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L499">            lattice.addNode(reduced.get(n));</span>
<span class="fc" id="L500">        }</span>
        // addtion of edges to lattice
<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (Node from : csl.getNodes()) {</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">            for (Node to : csl.getSuccessorNodes(from)) {</span>
<span class="fc" id="L504">                lattice.addEdge(reduced.get(from), reduced.get(to));</span>
<span class="fc" id="L505">            }</span>
<span class="fc" id="L506">        }</span>
<span class="fc" id="L507">        return lattice;</span>
    }

    /**
     * Returns a lattice where meet irreducibles node's content
     * is replaced by the first element of set B.
     *
     * Other nodes are replaced by a new comparable.
     *
     * @return  a lattice
     */
    public Lattice getMeetReduction() {
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L520">            return null;</span>
        }
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (!this.containsAllSetB()) {</span>
<span class="nc" id="L523">            return null;</span>
        }
<span class="fc" id="L525">        Lattice lattice = new Lattice();</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L527">            return lattice;</span>
        }
        //ConceptLattice csl = new ConceptLattice (this);
<span class="fc" id="L530">        ConceptLattice csl = this.clone();</span>
<span class="fc" id="L531">        csl.makeIrreduciblesReduction();</span>
<span class="fc" id="L532">        TreeSet&lt;Node&gt; meetIrr = csl.meetIrreducibles();</span>
        // addition to lattice of a comparable issued from each reduced closed set
<span class="fc" id="L534">        TreeMap&lt;Node, Node&gt; reduced = new TreeMap&lt;Node, Node&gt;();</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L536">            Concept c = (Concept) n;</span>
            Node nred;
<span class="pc bpc" id="L538" title="1 of 4 branches missed.">            if (c.hasSetB() &amp;&amp; meetIrr.contains(n)) {</span>
<span class="fc" id="L539">                nred = new Node(c.getSetB().first());</span>
            } else {
<span class="fc" id="L541">                nred = new Node();</span>
            }
<span class="fc" id="L543">            reduced.put(n, nred);</span>
<span class="fc" id="L544">        }</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L546">            lattice.addNode(reduced.get(n));</span>
<span class="fc" id="L547">        }</span>
        // addtion of edges to lattice
<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (Node from : csl.getNodes()) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            for (Node to : csl.getSuccessorNodes(from)) {</span>
<span class="fc" id="L551">                lattice.addEdge(reduced.get(from), reduced.get(to));</span>
<span class="fc" id="L552">            }</span>
<span class="fc" id="L553">        }</span>
<span class="fc" id="L554">        return lattice;</span>
    }

    /**
     * Returns a lattice where each join irreducible concept
     * is replaced by a node containing the first element of set A,
     * and each meet irreducible concept is replaced by a node contining the first element of set B.
     *
     * A concept that is at once join and meet irreducible is replaced by
     * a node containing the first element of set A and the first element of set B in a set.
     * Other nodes are replaced by an empty node.
     *
     * @return  a lattice
     */
    public Lattice getIrreduciblesReduction() {
<span class="fc" id="L569">        Lattice lattice = new Lattice();</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L571">            return lattice;</span>
        }
        //ConceptLattice csl = new ConceptLattice (this);
<span class="fc" id="L574">        ConceptLattice csl = this.clone();</span>
<span class="fc" id="L575">        csl.makeIrreduciblesReduction();</span>
<span class="fc" id="L576">        TreeSet&lt;Node&gt; joinIrr = csl.joinIrreducibles();</span>
<span class="fc" id="L577">        TreeSet&lt;Node&gt; meetIrr = csl.meetIrreducibles();</span>
        // addition to lattice of a comparable issued from each reduced closed set
<span class="fc" id="L579">        TreeMap&lt;Node, Node&gt; reduced = new TreeMap&lt;Node, Node&gt;();</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L581">            Concept c = (Concept) n;</span>
            // create a new Node with two indexed elements: the first of set A and the first of set B
<span class="pc bpc" id="L583" title="2 of 8 branches missed.">            if (c.hasSetA() &amp;&amp; c.hasSetB() &amp;&amp; meetIrr.contains(c) &amp;&amp; joinIrr.contains(c)) {</span>
<span class="nc" id="L584">                TreeSet&lt;Comparable&gt; content = new TreeSet&lt;Comparable&gt;();</span>
<span class="nc" id="L585">                content.add(c.getSetA().first());</span>
<span class="nc" id="L586">                content.add(c.getSetB().first());</span>
<span class="nc" id="L587">                Node nred = new Node(content);</span>
<span class="nc" id="L588">                reduced.put(n, nred);</span>
<span class="pc bpc" id="L589" title="1 of 4 branches missed.">            } else if (c.hasSetA() &amp;&amp; joinIrr.contains(n)) {</span>
                // create a new Node with the first element of set A
<span class="fc" id="L591">                Node nred = new Node(((Concept) n).getSetA().first());</span>
<span class="fc" id="L592">                reduced.put(n, nred);</span>
<span class="fc bfc" id="L593" title="All 4 branches covered.">            } else if (c.hasSetB() &amp;&amp; meetIrr.contains(n)) {</span>
                // create a new Node with the first element of set A
<span class="fc" id="L595">                Node nred = new Node(((Concept) n).getSetB().first());</span>
<span class="fc" id="L596">                reduced.put(n, nred);</span>
<span class="fc" id="L597">            } else {</span>
<span class="fc" id="L598">                reduced.put(n, new Node());</span>
            }
<span class="fc" id="L600">        }</span>
        // addtion of nodes to lattice
<span class="fc bfc" id="L602" title="All 2 branches covered.">        for (Node n : csl.getNodes()) {</span>
<span class="fc" id="L603">            lattice.addNode(reduced.get(n));</span>
<span class="fc" id="L604">        }</span>
        // addtion of edges to lattice
<span class="fc bfc" id="L606" title="All 2 branches covered.">        for (Node from : csl.getNodes()) {</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">            for (Node to : csl.getSuccessorNodes(from)) {</span>
<span class="fc" id="L608">                lattice.addEdge(reduced.get(from), reduced.get(to));</span>
<span class="fc" id="L609">            }</span>
<span class="fc" id="L610">        }</span>
<span class="fc" id="L611">        return lattice;</span>
    }

    /**
     * Generate the lattice composed of all the antichains of this component
     * ordered with the inclusion relation.
     *
     * This treatment is performed in O(??) by implementation of Nourine algorithm
     * that consists in a sequence of doubling intervals of nodes.
     *
     * @param   dag  a directed acyclic graph
     *
     * @return  the concept lattice
     */
    public static ConceptLattice idealLattice(DAGraph dag) {
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (!dag.isAcyclic()) {</span>
<span class="nc" id="L627">            return null;</span>
        }
        // initialise the poset of ideals with the emptyset
<span class="fc" id="L630">        ConceptLattice conceptLattice = new ConceptLattice();</span>
<span class="fc" id="L631">        int id = 1;</span>
<span class="fc" id="L632">        conceptLattice.addNode(new Concept(true, false));</span>
        // travel on graph according to a topological sort
<span class="fc" id="L634">        DAGraph graph = new DAGraph(dag);</span>
<span class="fc" id="L635">        graph.transitiveClosure();</span>
        // treatment of nodes according to a topological sort
<span class="fc" id="L637">        ArrayList&lt;Node&gt; sort = graph.topologicalSort();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (Node x : sort) {</span>
            // computation of Jx
<span class="fc" id="L640">            TreeSet&lt;Node&gt; jxmoins = new TreeSet&lt;Node&gt;(graph.getPredecessorNodes(x));</span>
            // storage of new ideals in a set
<span class="fc" id="L642">            TreeSet&lt;Concept&gt; toAdd = new TreeSet&lt;Concept&gt;();</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">            for (Node j1 : conceptLattice.getNodes()) {</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                if (((Concept) j1).containsAllInA(jxmoins)) {</span>
<span class="fc" id="L645">                     Concept newJ = new Concept(true, false);</span>
<span class="fc" id="L646">                     newJ.addAllToA(((TreeSet) ((Concept) j1).getSetA()));</span>
<span class="fc" id="L647">                     newJ.addToA(x);</span>
<span class="fc" id="L648">                     toAdd.add(newJ);</span>
                }
<span class="fc" id="L650">            }</span>
            // addition of the new ideals in conceptLattice
<span class="fc bfc" id="L652" title="All 2 branches covered.">            for (Concept newJ : toAdd) {</span>
<span class="fc" id="L653">                conceptLattice.addNode(newJ);</span>
<span class="fc" id="L654">            }</span>
<span class="fc" id="L655">        }</span>
        // computation of the inclusion relaton
<span class="fc bfc" id="L657" title="All 2 branches covered.">        for (Node node1 : conceptLattice.getNodes()) {</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            for (Node node2 : conceptLattice.getNodes()) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">                if (((Concept) node1).containsAllInA(((Concept) node2).getSetA())) {</span>
<span class="fc" id="L660">                    conceptLattice.addEdge(node2, node1);</span>
                }
<span class="fc" id="L662">            }</span>
<span class="fc" id="L663">        }</span>
<span class="fc" id="L664">        conceptLattice.transitiveReduction();</span>
<span class="fc" id="L665">        return conceptLattice;</span>
    }

    /**
     * Returns iceberg lattice whose concept contains enough observations.
     *
     * Are kept only concept whose number of observation is over threshold.
     * A top node is added to keep the lattice structure.
     *
     * @param threshold used to determine nodes to be kept.
     * @return iceberg lattice whose concept contains enough observations.
     */
    public ConceptLattice iceberg(float threshold) {
<span class="fc" id="L678">        ConceptLattice l = new ConceptLattice();</span>
<span class="fc" id="L679">        Concept b = (Concept) this.bottom();</span>
<span class="fc" id="L680">        int card = b.getSetB().size();</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        for (Node n : this.getNodes()) {</span>
<span class="fc" id="L682">            Concept cpt = (Concept) n;</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">            if ((float) cpt.getSetB().size() / (float) card &gt;= threshold) {</span>
<span class="fc" id="L684">                l.addNode(n);</span>
            }
<span class="fc" id="L686">        }</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        for (Node f : l.getNodes()) {</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">            for (Node t : l.getNodes()) {</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">                if (this.containsEdge(f, t)) {</span>
<span class="fc" id="L690">                    l.addEdge(f, t);</span>
                }
<span class="fc" id="L692">            }</span>
<span class="fc" id="L693">        }</span>
<span class="fc" id="L694">        Node t = this.top();</span>
<span class="fc" id="L695">        l.addNode(t);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        for (Node n : l.getWells()) {</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            if (!n.equals(t)) {</span>
<span class="nc" id="L698">                l.addEdge(n, t);</span>
            }
<span class="fc" id="L700">        }</span>
<span class="fc" id="L701">        return l;</span>
    }
    /* -------- STATIC CLOSEDSET LATTICE GENERATION FROM AN ImplicationalSystem OR A CONTEXT ------------------ */

    /**
     * Generates and returns the complete (i.e. transitively closed) closed set lattice of the
     * specified closure system, that can be an implicational system (ImplicationalSystem) or a context.
     *
     * The lattice is generated using the well-known Next Closure algorithm.
     * All closures are first generated using the method:
     * {@link ClosureSystem#allClosures}
     * that implements the well-known Next Closure algorithm.
     * Then, all concepts are ordered by inclusion.
     *
     * @param   init  a closure system (an ImplicationalSystem or a Context)
     *
     * @return  a concept lattice
     */
    public static ConceptLattice completeLattice(ClosureSystem init) {
<span class="fc" id="L720">        ConceptLattice lattice = new ConceptLattice();</span>
        // compute all the closed set with allClosures
<span class="fc" id="L722">        Vector&lt;Concept&gt; allclosure = init.allClosures();</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (Concept cl : allclosure) {</span>
<span class="fc" id="L724">            lattice.addNode(cl);</span>
<span class="fc" id="L725">        }</span>

        // an edge corresponds to an inclusion between two closed sets
<span class="fc bfc" id="L728" title="All 2 branches covered.">        for (Node from : lattice.getNodes()) {</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">            for (Node to : lattice.getNodes()) {</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">                if (((Concept) to).containsAllInA(((Concept) from).getSetA())) {</span>
<span class="fc" id="L731">                   lattice.addEdge(from, to);</span>
                }
<span class="fc" id="L733">            }</span>
<span class="fc" id="L734">        }</span>
        // Hasse diagram is computed
<span class="fc" id="L736">        return lattice;</span>
    }

    /**
     * Generates and returns the Hasse diagram of the closed set lattice of the
     * specified closure system, that can be an implicational system (ImplicationalSystem) or a context.
     *
     * The Hasse diagramm of the closed set lattice is
     * obtained by a recursively generation of immediate successors of a given closed set,
     * starting from the botom closed set. Implemented algorithm is an adaptation of Bordat's
     * algorithm where the dependance graph is computed while the lattice is generated.
     * This treatment is performed in O(cCl|S|^3log g) where S is the initial set of elements,
     * c is the number of closed sets that could be exponential in the worst case,
     * Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
     *
     * The dependance graph of the lattice is also computed while the lattice generation.
     * The dependance graph of a lattice encodes at once the minimal generators
     * and the canonical direct basis of the lattice .
     *
     * @param   init  a closure system (an ImplicationalSystem or a Context)
     *
     * @return  a concept lattice
     */
    public static ConceptLattice diagramLattice(ClosureSystem init) {
<span class="fc" id="L761">        ConceptLattice lattice = new ConceptLattice();</span>
        //if (Diagram) {
            // computes the dependance graph of the closure system
            // addition of nodes in the precedence graph
<span class="fc" id="L765">            DGraph graph = new DGraph();</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            for (Comparable c : init.getSet()) {</span>
<span class="fc" id="L767">                graph.addNode(new Node(c));</span>
<span class="fc" id="L768">            }</span>
<span class="fc" id="L769">            lattice.setDependencyGraph(graph);</span>
            // intialize the close set lattice with botom element
<span class="fc" id="L771">            Concept bot = new Concept(init.closure(new ComparableSet()), false);</span>
<span class="fc" id="L772">            lattice.addNode(bot);</span>
            // recursive genaration from the botom element with diagramLattice
<span class="fc" id="L774">            lattice.recursiveDiagramLattice(bot, init);</span>
            // minimalisation of edge's content to get only inclusion-minimal valuation for each edge
            /**for (Edge ed : lattice.dependanceGraph.getEdges()) {
                TreeSet&lt;ComparableSet&gt; valEd = new TreeSet&lt;ComparableSet&gt;(((TreeSet&lt;ComparableSet&gt;)ed.getContent()));
                for (ComparableSet X1 : valEd)
                    for (ComparableSet X2 : valEd)
                        if (X1.containsAll(X2) &amp;&amp; !X2.containsAll(X1))
                            ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).remove(X1);
            }**/
<span class="fc" id="L783">        return lattice;</span>
    }

    /**
     * Returns the Hasse diagramme of the closed set lattice of the specified closure system
     * issued from the specified concept.
     *
     * Immediate successors generation is an adaptation of Bordat's theorem
     * stating that there is a bijection
     * between minimal strongly connected component of the precedence subgraph issued
     * from the specified node, and its immediate successors.
     *
     * This treatment is performed in O(cCl|S|^3log g) where S is the initial set of elements,
     * c is the number of closed sets that could be exponential in the worst case,
     * Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
     *
     * @param   n     a concept
     * @param   init  a closure system
     */
    public void recursiveDiagramLattice(Concept n, ClosureSystem init) {
<span class="fc" id="L804">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = this.immediateSuccessors(n, init);</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">        for (TreeSet&lt;Comparable&gt; setX : immSucc) {</span>
<span class="fc" id="L806">            Concept c = new Concept(new TreeSet(setX), false);</span>
<span class="fc" id="L807">            Concept ns = (Concept) this.getNode(c);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">            if (ns != null)  {</span>
                // when ns already exists, addition of a new edge
<span class="fc" id="L810">                this.addEdge(n, ns);</span>
            } else { // when ns don't already exists, addition of a new node and recursive treatment
<span class="fc" id="L812">                this.addNode(c);</span>
<span class="fc" id="L813">                this.addEdge(n, c);</span>
<span class="fc" id="L814">                this.recursiveDiagramLattice(c, init);</span>
            }
<span class="fc" id="L816">        }</span>
<span class="fc" id="L817">    }</span>

    /**
     * Returns the list of immediate successors of a given node of the lattice.
     *
     * This treatment is an adaptation of Bordat's theorem stating that there is a bijection
     * between minimal strongly connected component of the precedence subgraph issued
     * from the specified node, and its immediate successors.
     *
     * This treatment is performed in O(Cl|S|^3log g) where S is the initial set of elements,
     * Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
     *
     * This treatment is recursively invoked by method recursiveDiagramlattice. In this case, the dependance graph
     * is initialised by method recursiveDiagramMethod, and updated by this method,
     * with addition some news edges and/or new valuations on existing edges.
     * When this treatment is not invoked by method recursiveDiagramLattice, then the dependance graph
     * is initialised, but it may be not complete. It is the case for example for on-line generation of the
     * concept lattice.
     *
     * @param   n     a node
     * @param   init  a closure system
     *
     * @return  a set of immediate successors
     */
    public Vector&lt;TreeSet&lt;Comparable&gt;&gt; immediateSuccessors(Node n, ClosureSystem init) {
        // Initialisation of the dependance graph when not initialised by method recursiveDiagramLattice
<span class="fc bfc" id="L844" title="All 2 branches covered.">        if (!this.hasDependencyGraph()) {</span>
<span class="fc" id="L845">            DGraph graph = new DGraph();</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">            for (Comparable c : init.getSet()) {</span>
<span class="fc" id="L847">                graph.addNode(new Node(c));</span>
<span class="fc" id="L848">            }</span>
<span class="fc" id="L849">            this.setDependencyGraph(graph);</span>
        }
        // computes newVal, the subset to be used to valuate every new dependance relation
        // newVal = F\predecessors of F in the precedence graph of the closure system
        // For a non reduced closure system, the precedence graph is not acyclic,
        // and therefore strongly connected components have to be used.
<span class="fc" id="L855">        ComparableSet setF = new ComparableSet(((Concept) n).getSetA());</span>
<span class="fc" id="L856">        DGraph prec = init.precedenceGraph();</span>
<span class="fc" id="L857">        DAGraph acyclPrec = prec.getStronglyConnectedComponent();</span>
<span class="fc" id="L858">        ComparableSet newVal = new ComparableSet();</span>
<span class="fc" id="L859">        newVal.addAll(setF);</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">        for (Object x : setF)  {</span>
            // computes nx, the strongly connected component containing x
<span class="fc" id="L862">            Node nx = null;</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">            for (Node cc : acyclPrec.getNodes()) {</span>
<span class="fc" id="L864">                TreeSet&lt;Node&gt; setCC = (TreeSet&lt;Node&gt;) cc.getContent();</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">                for (Node y : setCC) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">                    if (x.equals(y.getContent())) {</span>
<span class="fc" id="L867">                        nx = cc;</span>
                    }
<span class="fc" id="L869">                }</span>
<span class="fc" id="L870">            }</span>
            // computes the minorants of nx in the acyclic graph
<span class="fc" id="L872">            SortedSet&lt;Node&gt; ccMinNx = acyclPrec.minorants(nx);</span>
            // removes from newVal every minorants of nx
<span class="fc bfc" id="L874" title="All 2 branches covered.">            for (Node cc : ccMinNx) {</span>
<span class="fc" id="L875">                TreeSet&lt;Node&gt; setCC = (TreeSet&lt;Node&gt;) cc.getContent();</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">                for (Node y : setCC) {</span>
<span class="fc" id="L877">                    newVal.remove(y.getContent());</span>
<span class="fc" id="L878">                }</span>
<span class="fc" id="L879">            }</span>
<span class="fc" id="L880">        }</span>
        // computes the node belonging in S\F
<span class="fc" id="L882">        TreeSet&lt;Node&gt; nodes = new TreeSet&lt;Node&gt;();</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (Node in : this.getDependencyGraph().getNodes()) {</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (!setF.contains(in.getContent())) {</span>
<span class="fc" id="L885">                nodes.add(in);</span>
            }
<span class="fc" id="L887">        }</span>
        // computes the dependance relation between nodes in S\F
        // and valuated this relation by the subset of S\F
<span class="fc" id="L890">        TreeSet&lt;Edge&gt; edges = new TreeSet&lt;Edge&gt;();</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">        for (Node from : nodes) {</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">            for (Node to : nodes) {</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">                if (!from.equals(to)) {</span>
                    // check if from is in dependance relation with to
                    // i.e. &quot;from&quot; belongs to the closure of &quot;F+to&quot;
<span class="fc" id="L896">                    ComparableSet fPlusTo = new ComparableSet(setF);</span>
<span class="fc" id="L897">                    fPlusTo.add(to.getContent());</span>
<span class="fc" id="L898">                    fPlusTo = new ComparableSet(init.closure(fPlusTo));</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">                    if (fPlusTo.contains(from.getContent())) {</span>
                        // there is a dependance relation between from and to
                        // search for an existing edge between from and to
<span class="fc" id="L902">                        Edge ed = this.getDependencyGraph().getEdge(from, to);</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                        if (ed == null) {</span>
<span class="fc" id="L904">                            ed = new Edge(from, to, new TreeSet&lt;ComparableSet&gt;());</span>
<span class="fc" id="L905">                            this.getDependencyGraph().addEdge(ed);</span>
                        }
<span class="fc" id="L907">                        edges.add(ed);</span>
                        // check if F is a minimal set closed for dependance relation between from and to
<span class="fc" id="L909">                        ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).add(newVal);</span>
<span class="fc" id="L910">                        TreeSet&lt;ComparableSet&gt; valEd = new TreeSet&lt;ComparableSet&gt;((TreeSet&lt;ComparableSet&gt;) ed.getContent());</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">                        for (ComparableSet x1 : valEd) {</span>
<span class="fc bfc" id="L912" title="All 4 branches covered.">                            if (x1.containsAll(newVal) &amp;&amp; !newVal.containsAll(x1)) {</span>
<span class="fc" id="L913">                                ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).remove(x1);</span>
                            }
<span class="fc bfc" id="L915" title="All 4 branches covered.">                            if (!x1.containsAll(newVal) &amp;&amp; newVal.containsAll(x1)) {</span>
<span class="fc" id="L916">                                ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).remove(newVal);</span>
                            }
<span class="fc" id="L918">                        }</span>
                    }
                }
<span class="fc" id="L921">            }</span>
<span class="fc" id="L922">        }</span>
        // computes the dependance subgraph of the closed set F as the reduction
        // of the dependance graph composed of nodes in S\A and edges of the dependance relation
<span class="fc" id="L925">        DGraph sub = this.getDependencyGraph().getSubgraphByNodes(nodes);</span>
<span class="fc" id="L926">        DGraph delta = sub.getSubgraphByEdges(edges);</span>
        // computes the sources of the CFC of the dependance subgraph
        // that corresponds to successors of the closed set F
<span class="fc" id="L929">        DAGraph cfc = delta.getStronglyConnectedComponent();</span>
<span class="fc" id="L930">        SortedSet&lt;Node&gt; sccMin = cfc.getSinks();</span>
<span class="fc" id="L931">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = new Vector&lt;TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">        for (Node n1 : sccMin) {</span>
<span class="fc" id="L933">            TreeSet s = new TreeSet(setF);</span>
<span class="fc" id="L934">            TreeSet&lt;Node&gt; toadd = (TreeSet&lt;Node&gt;) n1.getContent();</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">            for (Node n2 : toadd) {</span>
<span class="fc" id="L936">                s.add(n2.getContent());</span>
<span class="fc" id="L937">            }</span>
<span class="fc" id="L938">            immSucc.add(s);</span>
<span class="fc" id="L939">        }</span>
<span class="fc" id="L940">       return immSucc;</span>
    }

    /**
     * Save the description of this component in a file whose name is specified.
     *
     * @param   filename  the name of the file
     *
     * @throws  IOException  When an IOException occurs
     */
    public void save(final String filename) throws IOException {
<span class="fc" id="L951">        String extension = &quot;&quot;;</span>
<span class="fc" id="L952">        int index = filename.lastIndexOf('.');</span>
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">        if (index &gt; 0) {</span>
<span class="fc" id="L954">            extension = filename.substring(index + 1);</span>
        }
<span class="fc" id="L956">        ConceptLatticeWriter writer = ConceptLatticeWriterFactory.get(extension);</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L958">            super.save(filename);</span>
        } else {
<span class="fc" id="L960">            BufferedWriter file = new BufferedWriter(new FileWriter(filename));</span>
<span class="fc" id="L961">            writer.write(this, file);</span>
<span class="fc" id="L962">            file.close();</span>
        }
<span class="fc" id="L964">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>