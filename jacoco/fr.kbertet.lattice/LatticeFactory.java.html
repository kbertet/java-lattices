<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LatticeFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">fr.kbertet.lattice</a> &gt; <span class="el_source">LatticeFactory.java</span></div><h1>LatticeFactory.java</h1><pre class="source lang-java linenums">package fr.kbertet.lattice;
/*
 * LatticeFactory.java
 *
 * Copyright: 2010-2014 Karell Bertet, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 */

import java.util.BitSet;
import java.util.Iterator;

import fr.kbertet.util.Couple;
import fr.kbertet.dgraph.DAGraph;
import fr.kbertet.dgraph.Node;

/**
 * This class provides a few methods to constructs lattice examples.
 *
 * ![LatticeFactory](LatticeFactory.png)
 *
 * @uml LatticeFactory.png
 * !include resources/fr/kbertet/lattice/LatticeFactory.iuml
 *
 * class LatticeFactory #LightCyan
 * title LatticeFactory UML graph
 * @author jeff
 */
public class LatticeFactory {
    /**
     * This class provides a representation of permutations.
     *
     * If this component transforms : 0 -&gt; 1, 1 -&gt; 0 &amp; 2 -&gt; 2.
     * Then its length is 3 and
     *
     * The content contains :
     *
     * ~~~
     * content[0]=1
     * content[1]=0
     * content[2]=2
     * ~~~
     */
    private static class Permutation {
        /**
         * This component is a permutation of 0..length-1.
         */
        private int length;

        /**
         * The transformation represented by this component.
         *
         * If this component transforms : 0 -&gt; 1, 1 -&gt; 0 &amp; 2 -&gt; 2.
         * The field content contains :
         *
         * ~~~
         * content[0]=1
         * content[1]=0
         * content[2]=2
         * ~~~
         */
        private int[] content;

        /**
         * Constructs identity of the set 0..n-1.
         *
         * @param   n  permutation of the set 0..n-1.
         */
<span class="fc" id="L72">        public Permutation(int n) {</span>
<span class="fc" id="L73">            this.length = n;</span>
<span class="fc" id="L74">            this.content = new int[n];</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L76">                this.content[i] = i;</span>
            }
<span class="fc" id="L78">        }</span>

        /**
         * Returns the transformation coded by this component.
         *
         * @return  the transformation coded by this component.
         */
        public int[] getContent() {
<span class="fc" id="L86">            return this.content;</span>
        }

        /**
         * Set the transformation coded by this component.
         *
         * Length of this component is update by this method.
         *
         * @param   c  the transformation coded in this component.
         *
         * @return  this for chaining
         */
        public Permutation setContent(int[] c) {
<span class="fc" id="L99">            this.content = c;</span>
<span class="fc" id="L100">            this.length = c.length;</span>
<span class="fc" id="L101">            return this;</span>
        }

        /**
         * Return length of this component.
         *
         * @return  length of this component.
         */
        public int getLength() {
<span class="fc" id="L110">            return this.length;</span>
        }

        /**
         * Set length of this componenet.
         *
         * @param   l  length of this component.
         *
         * @return  true if update is successful.
         */
        public boolean setLength(int l) {
<span class="nc bnc" id="L121" title="All 4 branches missed.">            if ((this.content.length == l) &amp;&amp; (l &lt;= this.getLength())) {</span>
<span class="nc" id="L122">                this.length = l;</span>
<span class="nc" id="L123">                return true;</span>
            } else {
<span class="nc" id="L125">                return false;</span>
            }
        }

        /**
         * Returns a string representation of this component.
         *
         * @return  a string representation of this component.
         */
        @Override
        public String toString() {
<span class="nc" id="L136">            String str = &quot;&quot;;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            for (int i = 0; i &lt; this.length; i++) {</span>
<span class="nc" id="L138">                str = str + this.content[i];</span>
            }
<span class="nc" id="L140">            return str;</span>
        }

        /**
         * Returns true if this component is equal to s.
         *
         * @param   s  test if this component is equal to s
         *
         * @return  true if this component is equal to s
         */
        public boolean equals(Permutation s) {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (!(s.getLength() == this.length)) {</span>
<span class="nc" id="L152">                return false;</span>
            } else {
<span class="fc" id="L154">                boolean tmp = true;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                for (int i = 0; i &lt; this.length; i++) {</span>
<span class="fc bfc" id="L156" title="All 4 branches covered.">                    tmp = tmp &amp;&amp; (this.content[i] == s.getContent()[i]);</span>
                }
<span class="fc" id="L158">                return tmp;</span>
            }
        }

        /**
         * Compute the hash code.
         *
         * @return  an integer representing the object
         */
        @Override
        public int hashCode() {
<span class="nc" id="L169">            return super.hashCode();</span>
        }
    }

    /**
     * Empty constructor.
     */
    protected LatticeFactory() {
<span class="fc" id="L177">        super();</span>
<span class="fc" id="L178">    }</span>

    /**
     * Returns a randomly generated lattice with nb nodes.
     *
     * @param   nb  Number of nodes in the randomly generated lattice
     *
     * @return  a randomly generated lattice with nb nodes
     */
    public static Lattice random(int nb) {
<span class="fc" id="L188">        boolean done = false;</span>
<span class="fc" id="L189">        Lattice l = new Lattice();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        while (!done) {</span>
<span class="fc" id="L191">            DAGraph dag = DAGraph.random(nb - 2); // what an ugly strategy :-(</span>
<span class="fc" id="L192">            Lattice tmp = new Lattice(dag);</span>
<span class="fc" id="L193">            Node top = new Node(new Integer(nb - 1));</span>
<span class="fc" id="L194">            tmp.addNode(top);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            for (Node n : tmp.max()) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (!n.equals(top)) {</span>
<span class="fc" id="L197">                    tmp.addEdge(n, top);</span>
                }
<span class="fc" id="L199">            }</span>
<span class="fc" id="L200">            Node bot = new Node(new Integer(nb));</span>
<span class="fc" id="L201">            tmp.addNode(bot);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (Node n : tmp.min()) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (!n.equals(bot)) {</span>
<span class="fc" id="L204">                    tmp.addEdge(bot, n);</span>
                }
<span class="fc" id="L206">            }</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (tmp.isLattice()) {</span>
<span class="fc" id="L208">                done = true;</span>
<span class="fc" id="L209">                l = tmp;</span>
            }
<span class="fc" id="L211">        }</span>
<span class="fc" id="L212">        return l;</span>
    }

    /**
     * Returns the boolean algebra of cardinal 2^n.
     *
     * @param   n  cardinal of the boolean algebra return by this method is 2^n
     *
     * @return  the boolean algebra of cardinal 2^n
     */
    public static Lattice booleanAlgebra(int n) {
<span class="fc" id="L223">        Lattice l = new Lattice();</span>
<span class="fc" id="L224">        BitSet b = new BitSet(n);</span>
<span class="fc" id="L225">        Node bot = new Node(b);</span>
<span class="fc" id="L226">        l.addNode(bot);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L228">            BitSet bs = new BitSet(n);</span>
<span class="fc" id="L229">            bs.set(i, true);</span>
<span class="fc" id="L230">            Node next = new Node(bs);</span>
<span class="fc" id="L231">            l.addNode(next);</span>
<span class="fc" id="L232">            l.addEdge(bot, next);</span>
<span class="fc" id="L233">            recursiveBooleanAlgebra(next, l, n);</span>
        }
<span class="fc" id="L235">        return l;</span>
    }

    /**
     * Computes successors of node n in the boolean algebra currently generated.
     *
     * @param   node  this method compute successors of this node
     * @param   l     boolean algebra currently generated
     * @param   n     the number of node of l will be 2^n at the end of computation
     */
    private static void recursiveBooleanAlgebra(Node node, Lattice l, int n) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L247">            BitSet b = (BitSet) node.getContent();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (!b.get(i)) {</span>
<span class="fc" id="L249">                BitSet bs = (BitSet) b.clone();</span>
<span class="fc" id="L250">                bs.set(i, true);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">                if (l.getNodeByContent(bs) == null) {</span>
<span class="fc" id="L252">                    Node next = new Node(bs);</span>
<span class="fc" id="L253">                    l.addNode(next);</span>
<span class="fc" id="L254">                    l.addEdge(node, next);</span>
<span class="fc" id="L255">                    recursiveBooleanAlgebra(next, l, n);</span>
<span class="fc" id="L256">                } else {</span>
<span class="fc" id="L257">                    l.addEdge(node, l.getNodeByContent(bs));</span>
                }
            }
        }
<span class="fc" id="L261">    }</span>

    /**
     * Returns the lattice of permutations of 1..n.
     *
     * Permutation are ordered as follows :
     * A permutation s2 is a succesor of a permutation s1, if s2 is obtained from s1 by inverting two consecutive
     * elements i and j such that before inversion j &gt; i.
     *
     * Example : 124356 has following successors 214356, 142356, 124536 and 124365.
     *
     * The bottom of this lattice is identity (for exemple 123456) and the top is for instance 654321.
     *
     * @param   n  the lattice of permutations of the set 1..n
     *
     * @return  the lattice of permutations of 1..n.
     */
    public static Lattice permutationLattice(int n) {
<span class="fc" id="L279">        Lattice l = new Lattice();</span>
<span class="fc" id="L280">        int[] content = new int[n];</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L282">            content[i] = i;</span>
        }
<span class="fc" id="L284">        Permutation s = new Permutation(n);</span>
<span class="fc" id="L285">        s.setContent(content);</span>
<span class="fc" id="L286">        Node bot = new Node(s);</span>
<span class="fc" id="L287">        l.addNode(bot);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (int i = 0; i &lt; n - 1; i++) {</span>
<span class="fc" id="L289">            int[] newC = content.clone();</span>
<span class="fc" id="L290">            newC[i] = content[i + 1];</span>
<span class="fc" id="L291">            newC[i + 1] = content[i];</span>
<span class="fc" id="L292">            Permutation newS = new Permutation(n);</span>
<span class="fc" id="L293">            newS.setContent(newC);</span>
<span class="fc" id="L294">            Node succ = new Node(newS);</span>
<span class="fc" id="L295">            l.addNode(succ);</span>
<span class="fc" id="L296">            l.addEdge(bot, succ);</span>
<span class="fc" id="L297">            recursivePermutationLattice(succ, l, n);</span>
        }
<span class="fc" id="L299">        return l;</span>
    }

    /**
     * Computes successors of node n in the lattice l.
     *
     * @param   node  successors of this node are computed by this method
     * @param   l     lattice of permutations currently generated
     * @param   n     lattice of permutation of the set 1..n is currently generated
     */
    private static void recursivePermutationLattice(Node node, Lattice l, int n) {
<span class="fc" id="L310">        Permutation s = (Permutation) node.getContent();</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (int i = 0; i &lt; s.getLength() - 1; i++) {</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (s.getContent()[i] &lt; s.getContent()[i + 1]) {</span>
<span class="fc" id="L313">                int[] newC = s.getContent().clone();</span>
<span class="fc" id="L314">                Node currentNode = new Node();</span>
<span class="fc" id="L315">                newC[i] = s.getContent()[i + 1];</span>
<span class="fc" id="L316">                newC[i + 1] = s.getContent()[i];</span>
<span class="fc" id="L317">                Permutation newP = new Permutation(n);</span>
<span class="fc" id="L318">                newP.setContent(newC);</span>
<span class="fc" id="L319">                boolean newNode = true;</span>
<span class="fc" id="L320">                Iterator&lt;Node&gt; it = l.getNodes().iterator();</span>
<span class="fc bfc" id="L321" title="All 4 branches covered.">                while (it.hasNext() &amp;&amp; newNode) {</span>
<span class="fc" id="L322">                    currentNode = it.next();</span>
<span class="fc" id="L323">                    Permutation currentContent = (Permutation) currentNode.getContent();</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">                    newNode = !(currentContent.equals(newP));</span>
<span class="fc" id="L325">                }</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">                if (newNode) {</span>
<span class="fc" id="L327">                    Permutation newS = new Permutation(n);</span>
<span class="fc" id="L328">                    newS.setContent(newC);</span>
<span class="fc" id="L329">                    Node next = new Node(newS);</span>
<span class="fc" id="L330">                    l.addNode(next);</span>
<span class="fc" id="L331">                    l.addEdge(node, next);</span>
<span class="fc" id="L332">                    recursivePermutationLattice(next, l, n);</span>
<span class="fc" id="L333">                } else {</span>
<span class="fc" id="L334">                    l.addEdge(node, currentNode);</span>
                }
            }
        }
<span class="fc" id="L338">    }</span>

    /**
     * Returns the lattice cartesian product of l and r.
     *
     * A node in the product is a cartesian product of two nodes
     *
     * There is an edge (n1, m1) -&gt; (n2, m2) if and only if there are edges n1 -&gt; n2 and m1 -&gt; m2
     *
     * @param   l  Lattice of the left hand side of the product
     * @param   r  Lattice of the right hand side of the product
     *
     * @return  the lattice cartesian product of l and r
     */
    public static Lattice product(Lattice l, Lattice r) {
<span class="fc" id="L353">        Lattice prod = new Lattice();</span>
        // Create nodes
<span class="fc bfc" id="L355" title="All 2 branches covered.">        for (Node nL : l.getNodes()) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            for (Node nR : r.getNodes()) {</span>
<span class="fc" id="L357">                prod.addNode(new Node(new Couple(nL.getContent(), nR.getContent())));</span>
<span class="fc" id="L358">            }</span>
<span class="fc" id="L359">        }</span>
        // Create edges
<span class="fc bfc" id="L361" title="All 2 branches covered.">        for (Node from : prod.getNodes()) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            for (Node to : prod.getNodes()) {</span>
<span class="fc bfc" id="L363" title="All 4 branches covered.">                if (l.containsEdge(l.getNodeByContent(((Couple) from.getContent()).getLeft()),</span>
                        l.getNodeByContent(((Couple) to.getContent()).getLeft()))
                        &amp;&amp; r.containsEdge(r.getNodeByContent(((Couple) from.getContent()).getRight()),
                                r.getNodeByContent(((Couple) to.getContent()).getRight()))) {
<span class="fc" id="L367">                    prod.addEdge(from, to);</span>
                }
<span class="fc" id="L369">            }</span>
<span class="fc" id="L370">        }</span>
<span class="fc" id="L371">        return prod;</span>
    }
    /**
     * Returns lattice l in which convex c has been doubled.
     *
     * @param   l  a lattice
     * @param   c  a convex subset of l, to be doubled.
     *
     * @return  a lattice construct from l by doubling the convex subset c.
     */
    public static Lattice doublingConvex(Lattice l, DAGraph c) {
<span class="fc" id="L382">        Lattice doubled = new Lattice();</span>
        // Copy nodes by Content
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (Node n : l.getNodes()) {</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">            if (c.containsNode(n)) {</span>
                // These nodes are doubled
<span class="fc" id="L387">                Couple cpl0 = new Couple(n.getContent(), 0);</span>
<span class="fc" id="L388">                Node n0 = new Node(cpl0);</span>
<span class="fc" id="L389">                Couple cpl1 = new Couple(n.getContent(), 1);</span>
<span class="fc" id="L390">                Node n1 = new Node(cpl1);</span>
<span class="fc" id="L391">                doubled.addNode(n0);</span>
<span class="fc" id="L392">                doubled.addNode(n1);</span>
<span class="fc" id="L393">            } else {</span>
                // These nodes are just copied
<span class="fc" id="L395">                doubled.addNode(new Node(n.getContent()));</span>
            }
<span class="fc" id="L397">        }</span>
        // Construct edges of doubled
<span class="fc" id="L399">        Couple test = new Couple(0, 0); // used to test class of contents</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (Node x : doubled.getNodes()) {</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            for (Node y : doubled.getNodes()) {</span>
                // Add an edge if x &lt; y
<span class="fc bfc" id="L403" title="All 2 branches covered.">                if (x.getContent().getClass() == test.getClass()) { // x was in convex c</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">                    if (y.getContent().getClass() == test.getClass()) { // y was also in convex c</span>
                        // x &amp; y were in convex c
<span class="fc" id="L406">                        Couple cX = (Couple) x.getContent();</span>
<span class="fc" id="L407">                        Couple cY = (Couple) y.getContent();</span>
<span class="fc bfc" id="L408" title="All 6 branches covered.">                        if ((cX.getLeft() == cY.getLeft()) &amp;&amp; (((Integer) cX.getRight()).intValue() == 0)</span>
                                &amp;&amp; (((Integer) cY.getRight()).intValue() == 1)) {
                            // Same content means same node. x is of the form (cX, 0) and y is of the for (cX, 1) so x &lt; y in doubled.
<span class="fc" id="L411">                            doubled.addEdge(x, y);</span>
                        } else {
<span class="fc bfc" id="L413" title="All 4 branches covered.">                            if (l.majorants(l.getNodeByContent(cX.getLeft())).contains(l.getNodeByContent(cY.getLeft()))</span>
                                    &amp;&amp; (cX.getRight() == cY.getRight())) {
                                // x &lt; y in l and x &amp; y have the same second component si x &lt; y in doubled.
<span class="fc" id="L416">                                doubled.addEdge(x, y);</span>
                            }
                        }
<span class="fc" id="L419">                    } else { // y wasn't in convex c</span>
                        // x was in c &amp; y wasn't
<span class="fc" id="L421">                        Couple cX = (Couple) x.getContent();</span>
<span class="fc bfc" id="L422" title="All 4 branches covered.">                        if (l.majorants(l.getNodeByContent(cX.getLeft())).contains(l.getNodeByContent(y.getContent()))</span>
                                &amp;&amp; (((Integer) cX.getRight()).intValue() == 1)) {
                            // x &lt; y in l and second component of x is 1.
<span class="fc" id="L425">                            doubled.addEdge(x, y);</span>
                        }
<span class="fc" id="L427">                    }</span>
                } else { // x wasn't in convex c
<span class="fc bfc" id="L429" title="All 2 branches covered.">                    if (y.getContent().getClass() == test.getClass()) { // y was in convex c</span>
                        // x wasn't in c but y was
<span class="fc" id="L431">                        Couple cY = (Couple) y.getContent();</span>
<span class="fc bfc" id="L432" title="All 4 branches covered.">                        if (l.majorants(l.getNodeByContent(x.getContent())).contains(l.getNodeByContent(cY.getLeft()))</span>
                                &amp;&amp; (((Integer) cY.getRight()).intValue() == 0)) {
                                // x &lt; y in l and x &amp; second component of y is 0.
<span class="fc" id="L435">                                doubled.addEdge(x, y);</span>
                            }
<span class="fc" id="L437">                    } else { // y wasn't in convex c</span>
                        // x wasn't in c nor y
<span class="fc bfc" id="L439" title="All 2 branches covered.">                        if (l.majorants(l.getNodeByContent(x.getContent())).contains(l.getNodeByContent(y.getContent()))) {</span>
                                // x &lt; y in l and x &amp; second component of y is 0.
<span class="fc" id="L441">                                doubled.addEdge(x, y);</span>
                            }
                    }
                }
<span class="fc" id="L445">            }</span>
<span class="fc" id="L446">        }</span>
<span class="fc" id="L447">        doubled.transitiveReduction();</span>
<span class="fc" id="L448">        return doubled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>